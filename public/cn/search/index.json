[{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/","subtitle":null,"title":"Ergo"},{"contents":"如何设置和配置Ergo全节点\n本教程说明了如何安装和运行Ergo全节点，不涵盖挖矿。\n Windows用户还可以观看视频教程。\n如何在Windows上设置和配置Ergo全节点 视频链接：https://www.youtube.com/watch?v=fpEDJ1CM6ns\n节点安全\n这里是节点使用的一些重要方面，您的钱包及代币是否安全将取决于这些方面：\n Ergo节点需要在配置文件中存储安全关键参数。切勿公开此文件。 Ergo节点提供一个REST API，用于与内置钱包进行交互。敏感的API方法需要安全令牌，切勿通过不受信任渠道发送该令牌。 须将Ergo REST API的访问权限限于已知主机。特别是，不得从Internet访问该API。  前提条件\n如要运行Ergo节点，您需要在系统上安装JDK/JRE version \u0026gt;= 9。我们建议使用版本9或11。做到这一点的一种方法是安装Oracle Java SE。\n请注意，不再支持Oracle JDK/JRE \u0026lt;= 8。\n下一步是下载最新的Ergo客户端（Ergo client release）jar文件并创建节点配置文件。\n请注意，您可以通过发出sbt assembly命令，使用SBT克隆存储库并根据源代码编译jar，而不是下载预编译好的Ergo jar。\n创建一个专用文件夹（例如~/ergo）以运行该节点。用ergo_folder表示保存jar的文件夹。\n首次运行节点\n使用ergo_folder中的以下文本创建配置文件ergo.conf。\nergo { node { mining = false } }\n打开命令提示符并cd到ergo_folder。然后发出以下命令来首次运行节点：\njava -jar ergo-\u0026lt;release\u0026gt;.jar --mainnet -c ergo.conf\n此后，节点将立即开始同步。等待几分钟，以启动API，然后继续下一步。\n**注意：**此文件可使用任何名称，而非ergo.conf。所有配置参数都将通过此文件传递，您只需要重写您想要从默认值开始修改的参数即可。上面的配置文件实际上具有默认值。\n计算您密语的哈希\n首先，选择一个密语来保护您的API。然后转到http://127.0.0.1:9053/swagger#/utils/hashBlake2b并调用API以计算您密语的哈希。请参考下图：\n复制包含哈希的响应，以用于下一步（请参见下图）。在我们的示例中，密语（Secret）是hello，其哈希对应于324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf。\n重要提示 您须将此密语更为其他安全性强的密语。\n使用API密钥哈希更新配置文件\n编辑配置文件ergo.conf并粘贴上一步中复制的哈希。该文件应如下所示：\nergo { node { mining = false } }\nscorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string 'hello' # replace with your actual hash apiKeyHash = \u0026quot;324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\u0026quot; } }\n初始化钱包\n重新启动节点，然后转到http://127.0.0.1:9053/panel以访问面板。然后设置上一步中的API密钥密语。请注意，您需要设置密语，而不是配置文件中的哈希。在我们的示例中，这是字符串hello。\n点击初始化钱包（Initialize wallet）。弹出窗口打开后，有两种方式可继续，根据您的情况而定。\n  如果这是您第一次运行该节点，则需要使用新的助记词对节点进行初始化。\n  如果您之前已创建一个钱包且想获得相同的地址（可能是因为此钱包中存储了资金），那么您须使用之前保存的助记词来恢复该钱包。\n  请根据您的具体情况执行以下步骤之一。\n从头开始初始化钱包\n在打开的弹出窗口中，您须输入钱包密码。助记密码是可选的。单击发送后，钱包将返回助记词，如下所示。\n您须誊写这些助记词并将其保存在安全的地方。在另一台电脑上恢复钱包时需用到这些助记词。\n用**先前数据恢复钱包**\n复制先前数据中的助记词并将其粘贴到“Restore-wallet （恢复钱包）”表单的“Mnemonic（助记词）”字段中。输入安全的钱包密码。将助记密码保留为空（仅适用于高级用户）。请参考下图。\n利用助记词成功恢复钱包后，您将看到确认信息，如下图所示。\n获取钱包地址\n此举旨在测试确保您正确设置了节点。它将返回钱包中的当前地址。在 http://127.0.0.1:9053/panel的面板中，单击左侧的“Wallet（钱包）”选项卡，然后在“Get all wallet addresses（获取所有钱包地址）”上单击以查看该钱包当前维护的地址。如果节点设置正确，它应该至少返回一个地址。\n检查节点是否已同步\n节点正在同步时，面板将显示“Active synchronization（同步活跃）”（请参见下图）。\n节点完全同步后，上述文字会变为“Node is synced（节点已同步）”，如下所示。\n查看钱包余额\n发送资金\n如果余额不为零，则可以使用面板将ERG发送到任何其他地址，如下所示：\n**查看Swagger用户**界面\n可以在http://127.0.0.1:9053/swagger中找到Swagger用户界面。您之前已经使用它来计算密语的哈希。您还可以使用此用户界面对面板中尚不可用的高级操作进行API调用。例如：\n 使用寄存器和上下文变量创建非标准交易。 创建发出代币的交易。 创建使用某些币盒作为输入的交易。  以后的文章将详细介绍上述每项操作。\n请注意，API中的大多数方法都是受保护的，您将需要使用您的密语（从先前数据获得）来访问这些方法。在Swagger用户界面中设置此密语的过程如下图所示。\n输入密码并单击“Authorize（授权）”后，将显示以下弹出窗口：\n现在，在您输入密码的同一选项卡中导航至http://127.0.0.1:9053/swagger#/wallet/walletAddresses，然后单击“Try it out（试用）”。您应该会看到您先前在面板中看到的同一地址列表。\n英文原版（可能会有更新）：\nhttps://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2021-01-21-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%92%8C%E9%85%8D%E7%BD%AEergo%E5%85%A8%E8%8A%82%E7%82%B9/","subtitle":null,"title":"如何设置和配置Ergo全节点"},{"contents":"Ergo GPU挖矿\n本文将帮助您开始使用GPU挖矿Ergo原生代币ERG。\nErgo挖矿基于Autolykos，即一种工作量证明（PoW）算法，被设计为阻碍ASIC矿机和矿池。矿工须执行存储困难的计算（需要至少4 GB的内存，但是当前最有效的实现使用的是8 GB的vRAM），这使得Ergo对GPU挖矿非常友好。此外，Autolykos要求访问私钥，从而防止形成矿池**（译注：Ergo于2021年2月1日硬分叉升级，从Autolykos v1升级为Autolykos V2，硬分叉后，将开启“人人挖矿”新时代，不再阻碍ASIC矿机和矿池，届时2GB及以上的GPU可参与挖矿**）。一旦找到正确答案，矿工将答案和区块一起广播，并能使用他在挖矿过程中使用的密语在延迟720个区块后收到区块奖励。网络的其他矿工将使用该矿工的**公**钥来验证答案，且可以非常高效地完成此验证，所需内存不到一千字节。\n前提条件\n为了进行挖矿，您需要完成以下设置：\n 带钱包的全节点，已初始化并完全同步。 配置有GPU的电脑，已获得您的操作系统认可。 适用于您的操作系统的Ergo挖矿软件。Ergo支持AMD和NVidia GPU。  Ergo挖矿需要已配置好且已同步的Ergo节点和至少一个GPU来进行挖矿。如果愿意，您可以使用多个GPU（以倍增您的算力），但只需要一个Ergo节点即可。\n请注意，由于Java 8缺少强大的加密技术，Ergo不再在Java 8中运行。您须使用Java\u0026gt; = 9\n设置挖矿软件的链接为：\n Nvidia Miner（Nvidia挖矿软件） AMD Miner（AMD挖矿软件）  ！！！警告！！！ 由于Autolykos使用私钥，因此，千万不要使用不受信任的挖矿软件。请核实软件是否开源并得到社区验证\n同步节点并初始化钱包\n请按照教程中所述的步骤设置节点。\n编辑节点的配置文件并添加以下行。\nergo.node.mining = true\n确保钱包已初始化，且您拥有正确的助记词。\n最后，确保按照此处所述同步节点。\n配置并运行挖矿软件\n在运行挖矿软件的电脑上，创建一个名为config.json的文件，其中包含以下内容\n{ \u0026quot;seed\u0026quot;: \u0026quot;Attention!!! Replace this with your mnemonic sentence and keep it secret or you will get robbed\u0026quot;, \u0026quot;node\u0026quot;: \u0026quot;http://192.168.1.100:9053\u0026quot;, \u0026quot;keepPrehash\u0026quot;: false }\n其中：\nseed 指在上一步中从您节点的钱包中获取的助记词。\nnode 是您节点的URL。\nkeepPrehash 是一个优化参数。如果设置为true，则挖矿软件最多将消耗8GB的内存。如果设置为false，则挖矿软件最多将消耗4GB的内存，但其性能会下降约25%。\n使用命令./auto.out config.json（如是Linux）或miner.exe config.json（如是Windows）运行您的挖矿软件，享受获取区块奖励吧！\n收到任何挖矿奖励后，您可以按照此处所述查看余额，然后按照此处所述提币。\n\n英文原版（可能会有更新）：\nhttps://github.com/ergoplatform/ergo/wiki/Mining-Ergo-for-Fun-and-Profit\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2021-01-21-%E6%97%A2%E6%83%B3%E4%BA%AB%E5%8F%97%E4%B9%90%E8%B6%A3%E5%8F%88%E6%83%B3%E8%B5%9A%E5%8F%96%E5%88%A9%E6%B6%A6-%E9%82%A3%E5%B0%B1%E8%B5%B6%E7%B4%A7%E6%9D%A5%E6%8C%96erg/","subtitle":null,"title":"既想享受乐趣，又想赚取利润？ ——那就赶紧来挖ERG"},{"contents":"适用于ergoplatform.com的OpenCL挖矿软件\n您可以在以下位置找到CUDA挖矿软件：CUDA挖矿软件\n层代理（Stratum Proxy）\n如要将此挖矿软件跟Stratum Pool（层矿池）一同使用，需要层代理。\n  安装 Ergo层代理（Ergo Stratum Proxy)\n  更新代理的 client.js 文件：\n  代理运行端口（可选。默认为3000）\n  矿池地址和端口\n  启动代理\n  在此挖矿软件的配置文件中，将节点地址设置为代理的地址（默认情况下，此地址为：{ \u0026quot;node\u0026quot; : \u0026quot;https://127.0.0.1:3000\u0026quot; }）\n  配置\n下面这些文件须与可执行文件位于同一文件夹中：\n Miningkernel.cl Prehashkernel.cl Ocldecs.h Ocldefs.h Libcurl.dlll（在Windows中）::: win64文件夹中有一个libcurl.dll文件，可以使用它，或者最好用您自己的内置文件替换它 Config.json  使用您节点的地址更改config.json文件。\n需求（Linux）\n1 - 为Ubuntu安装AMDGPU PRO驱动程序。\n从amd.com下载适用于Linux发行版的AMDGPU-PRO软件包，对下载的文件进行解压并运行：\n$ amdgpu-pro-install --opencl=legacy,pal --headless\n2 - Opencl标头\n$ sudo apt-get install opencl-headers\n3 - libcurl库：安装运行\n$ apt install libcurl4-openssl-dev\n4- OpenSSL 1.0.2库：安装运行\n$ apt install libssl-dev\n需求（Windows）\n AMD显卡，已安装驱动程序 下载并安装[AMD APK](https://github.com/mhssamadani/Autolykos2_AMD_Miner/blob/main/amd-dev.wpengine.netdna-cdn.com/app-sdk/installers/APPSDKInstaller/3.0.130.135-GA/full/AMD-APP-SDKInstaller-v3.0.130.135-GA-windows-F-x64.exe) 使用Visual Studio[工具链说明](https://medium.com/@chuy.max/compile-libcurl-on-windows-with-visual-studio-2017-x64-and-ssl-winssl-cff41ac7971d)从源代码构建libcurl 从[slproweb.com](https://slproweb.com/download/Win64OpenSSL-1_0_2t.exe)下载OpenSSL 1.0.2安装程序 下载并安装[Visual C ++可再发行组件](https://aka.ms/vs/16/release/vc_redist.x64.exe)  构建（Linux）\n 将目录更改为Ubuntu 运行make 如果make成功完成，将出现可执行文件Autolykos2_AMD_Miner/Ubuntu/ErgoOpenCL，该可执行文件可以以**./ErgoOpenCL**开头  构建（Windows）\n使用Visual Studio\n添加OpenCL、LibCurl、OpenSSl库\n包括目录：\n其他包括目录：\n其他库目录：\n其他依赖项：\nHttp信息\n此挖矿软件的HTTP信息页面位于http://miningnode:36207，采用json格式，页面显示GPU的状态（算力、风扇速度、温度等）。\n捐款与支持\n请注意，此挖矿软件是免费使用的，我们不会从您挖到的代币中收取任何费用。为了支持我们正在进行的所有工作，欢迎ERGO矿工向我们捐款！\n比特币：3KkwygpCLs1oEi9aTozFxYunoASV6ZrykJ\n比特币：bc1q7flay376e5mcp4ljjxpdp7r6p8yajcjm5mu6wd\nERGO：9fFUw6DqRuyFCv13nQyoDuDz4TiR4GvVvWRcSvqzs39eBVcb5S1\n英文原版（可能会有更新）：\nhttps://github.com/mhssamadani/Autolykos2_AMD_Miner\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2021-01-21-%E9%80%82%E7%94%A8%E4%BA%8Eamd-gpu%E7%9A%84autolykos-v2ergo%E7%9A%84opencl%E6%8C%96%E7%9F%BF%E8%BD%AF%E4%BB%B6/","subtitle":null,"title":"适用于AMD GPU的Autolykos v2（Ergo）的OpenCL挖矿软件"},{"contents":"用于ergoplatform.com的Cuda挖矿软件\n您可以在以下位置找到OpenCL挖矿软件：OpenCL挖矿软件\n层代理（Stratum Proxy）\n如要将此挖矿软件跟层矿池（Stratum Pool）一同使用，需要层代理。\n 安装Ergo层代理（Ergo Stratum Proxy） 更新代理的*client.js*文件： 端口运行端口（可选。默认为3000） 矿池地址和端口 启动代理 在挖矿软件的配置文件中，将节点地址设置为代理的地址（默认情况下，此地址为：{ \u0026quot;node\u0026quot; : \u0026quot;https://127.0.0.1:3000\u0026quot; }）  前提条件（Linux）\n（对于Ubuntu 16.04或18.04）\n如要编译，您需要具备以下条件：\n1. CUDA工具包：请参阅安装指南\n2. 与已安装的工具包兼容的CUDA驱动程序：请参阅兼容性列表\n3. libcurl库：安装运行\n$ apt install libcurl4-openssl-dev\n4. OpenSSL 1.0.2库：安装运行\n$ apt install libssl-dev\n安装（Linux）\n1. 将目录更改为Autolykos2_NV_Miner/secp256k1\n2. 运行make\n如果make成功完成，将出现可执行文件Autolykos2_NV_Miner/secp256k1/auto.out和（如果尚无）包含存根内容的配置文件Autolykos2_NV_Miner/secp256k1/config.json。\n安装（Windows 64位）\n2. 使用Visual Studio工具链说明从源代码构建libcurl\n3. 从slproweb.com下载OpenSSL 1.0.2安装程序\n4. 编辑secp256k1/buildwin.cmd文件，将OPENSSL_DIR、LIBCURL_DIR更改为您的libcurl和OpenSSL目录，将CUDA_COMPUTE_ARCH更改为所需的GPU代码架构\n5. 找到vcvars64.bat脚本，它应该在VISUAL_STUDIO_INSTALL_DIRECTORY\\VC\\Auxiliary\\Build中\n6. 运行cmd.exe，运行vcvars64.bat脚本，然后将目录更改为secp256k1，然后运行buildwin.cmd\n7. 如果一切顺利，miner.exe应该出现在secp256k1目录中\n8. 如果miner.exe找不到nvml.dll，请在运行之前将C:\\Program Files\\NVIDIA Corporation\\NVSMI添加到PATH环境变量中。\n运行（Linux）\n 如要运行此挖矿软件，您应该传递作为可选参数的配置文件名称\\`[YOUR_CONFIG]` 如果未指定文件名，则此挖矿软件将尝试使用Autolykos2_NV_Miner/secp256k1/config.json作为配置 配置文件须包含以下结构的json字符串：  { \u0026quot;node\u0026quot; : \u0026quot;https://127.0.0.1:9052\u0026quot; }\n如要在所有可用的CUDA设备上运行此挖矿软件，请输入：\n$ \u0026lt;YOUR_PATH\u0026gt;/Autolykos2_NV_Miner/secp256k1/auto.out [YOUR_CONFIG]\n如要选择CUDA设备，请更改并使用runner.sh或直接修改环境变量CUDA_VISIBLE_DEVICES\n运行（Windows 64位）\n 在挖矿软件目录中创建具有以下结构的config.json文件：{ \u0026quot;node\u0026quot; : \u0026quot;https://127.0.0.1:9052\u0026quot; }  如要调整可用于挖矿软件的CUDA设备，请修改环境变量CUDA_VISIBLE_DEVICES，例如，set CUDA_VISIBLE_DEVICES=\u0026quot;0,1\u0026quot;\nHTTP信息\n此挖矿软件的HTTP信息页面位于http://miningnode:36207（将-DHTTPAPI_PORT XXXX添加到Makefile中，即可修改默认端口）。\n它以JSON格式输出总算力、每个GPU的算力、功耗和温度（取决于NVML，如果NVML失败，则它也会失效——如果失效，JSON包含错误字段）。\n英文原版（可能会有更新）：https://github.com/mhssamadani/Autolykos2_NV_Miner\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2021-01-21-%E9%80%82%E7%94%A8%E4%BA%8Envidia-gpu%E7%9A%84autolykos-v2ergo%E7%94%A8cuda%E6%8C%96%E7%9F%BF%E8%BD%AF%E4%BB%B6/","subtitle":null,"title":"适用于Nvidia GPU的Autolykos v2（Ergo）用Cuda挖矿软件"},{"contents":"尔格基金会将考虑支持重大生态系统开发项目提供资助的建议。\n尔格是一个面向社区的项目，该生态系统的方方面面都有许多贡献者。尔格基金会会拿出一部分资金资助此项工作，这对于构建用户所需的日常产品与服务以及更多样化的金融去中心化应用至关重要。该基金会正在积极寻求新的资助，并刚刚投票接受了一项旨在改善所有dApp开发者的体验的全新建议。\n尔格dApp基础设施设置工具\n此项最新建议是由FiveBinaries的Marek提出的，他还负责构建首个卡尔达诺-尔格预言机解决方案。\n 目前，由于资料有限，开发者很难搭建必要的基础设施以支持你的dApps。该项目通过开发一个优化搭建尔格节点的流程、浏览器后端/前端情况以及重要监控/登录工具，以针对该生态系统的痛点。\n 这将大幅改善dApp开发者的体验，因为开发者只需运行一两个命令就可以托管他们自己的基础设施。因此该生态系统将进一步去中心化，更多节点/浏览器情况分散在世界各地。因此，区块链自身和其上的dApp基础设施的强适应力将会得到大幅提升，同时显著改善开发者的体验。\n 提交你的建议\n尔格基金会邀请开发者提交新的资助建议书，以加速推进并去中心化关键尔格生态系统服务的建设流程。建议应包括：\n 项目整体摘要 既定目标 时间表 请求资助的规模  以下收录了FiveBinaries资助建议的前两章作为例子\n # 托管尔格的基础设施 为了使dApps开发人员更容易托管他们的基础设施，无论是作为对用户的服务，还是其应用的开发，我想提出一个项目，通过提供开箱即用的解决方案来提升体验。 # 待办事项 开箱即用体验(The out-of-box experience)是由以下组件构成的集群。 * 尔格节点 * 尔格浏览器 \u0026lt;!----\u0026gt; * 尔格前端 \u0026lt;!----\u0026gt; * 尔格后端（chain-grabber, explorer-api, utx-broadcaster 和 utx-watcher) \u0026lt;!----\u0026gt; * 监控 \u0026lt;!----\u0026gt; * Grafana (参数) \u0026lt;!----\u0026gt; * ELK (logs) 该项目将利用docker-compose来设置多个形成集群(cluster)的容器。  如果你有好的想法，希望能从整体上改善尔格生态系统，请发送邮件到ergoplatform@protonmail.com申请尔格基金会的资助。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-12-11-%E5%B0%94%E6%A0%BC%E5%9F%BA%E9%87%91%E4%BC%9A%E4%B8%BA%E4%B8%BB%E8%A6%81%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%BA%94%E7%94%A8-dapp-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%8F%90%E4%BE%9B%E8%B5%84%E5%8A%A9/","subtitle":null,"title":"尔格基金会为主要去中心化应用(dApp)基础设施提供资助"},{"contents":"此次大型拍卖将为由我们匿名开发者(anons)所开展的开发工作进行融资，并且为所有人提供一个了解尔格历史的机会，这要感谢与所有尔格钱包进行合作的最新版拍卖公司\n 尔格的拍卖行的推出对于尔格平台来说是一家重要的里程碑。尔格非同质化代币为其他区块链上的币种提供其他功能，我们在10月份举行的拍卖出售了 有史以来第一个工作量证明支持的非同质化代币 以为开发者进行筹资。出售了非同质化代币以换取1,027个ERG。\n那时，只有在运行自己的节点时，才可能在拍卖时竞标，这使得大多数社区难以参与。\n这次我们将推出另一场拍卖会，再次为我们已经做出很多了不起贡献的匿名开发者(anon devs)筹集资金。他们已经做了非常多了不起的工作。这一次，所推出新服务意味着所有钱包都可以使用！\n  此次拍卖会会略有不同。非同质化代币将是我们新的尔格吉祥物 – 尔格宇航员(“Ergonaut”) - 的第一个形象。尔格宇航员拥有多种未来主义的工具，我们将适时看到他更多这方面的特征。我们想出售这一形象来向社区介绍尔格宇航员，并且这对于拍卖行也标志着最近动态。\n与尔格宇航员挂钩的非同质化代币将包含某些信息：\n我们匿名开发者(anons)的数字纪念碑。代币标识(token id)由币箱产生，其（在寄存器中）包含字符串“anon_92048 | anon2020* | anon_real”. 匿名开发者已经为尔格生态系统做了许多贡献，包括ErgoMixer、ZK Treasury和拍卖行。\n32 bits of work (token id: 000000002306564c7b03a78b76a2ce1d9d4e748ddf462cb73cc30b48e43e6e44).\n尔格宇航员的性格图像与非同质化代币相关联（对概念没有权利）。发行代币的币箱含有图像哈希\n存放在#8寄存器中的 “059c321fad7e0b2bb474ebea46c8978d1957eb1b5f11c589e52f129d14b3bde4”\n来自此次出售的全部资金将全部转给我们的匿名开发者，让他们能够继续为尔格生态系统开发酷炫的新功能。\n如果你不运行你自己的节点，你依然可以利用交易汇编程序(Assembler)服务竞标此次拍卖。点击拍卖网站右上角的‘安装钱包’键，点击‘任意钱包’，并且填入你的地址。\n当你出价的时候，你会收到一个地址，以发送你的ERG。适用于标准规则：如果你出价胜出，你的ERG将被立即自动发还给你。\n祝好运，祝竞拍顺利！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-12-09-%E5%BC%95%E5%85%A5%E5%B0%94%E6%A0%BC%E5%AE%87%E8%88%AA%E5%91%98%E5%B0%94%E6%A0%BC%E5%9F%BA%E9%87%91%E4%BC%9A%E5%87%BA%E5%94%AE%E9%9D%9E%E5%90%8C%E8%B4%A8%E5%8C%96%E4%BB%A3%E5%B8%81/","subtitle":null,"title":"引入‘尔格宇航员’：尔格基金会出售非同质化代币！"},{"contents":"Magnum是这种针对ERG和其他货币开发的深受欢迎的快捷钱包(lite wallet)将在本月底停运。\n许多尔格社区都在使用Magnum钱包，其是最早一批为ERG提供支持解决方案的快捷多钱包之一。\n 很遗憾，Magnum钱包将在本月底停用。Magnum团队最近在电报群(Telegraph)发布公告：\n尊敬的用户：\n今天我们很遗憾的通知您，20天后Magnum钱包将暂停服务。\n今年是很难的一年，这对我们来说也是一个艰难的决定。\n我们想提醒您Magnum钱包是一个非保管钱包。Magnum钱包既不获取，也不存储个人数据，只向您提供来自区块链的浏览数据。你可以利用任何其他加密货币钱包，通过你的私钥进入区块链。\n我还想提醒您你应当保管好你的私钥。我们会定期建议您把私钥从Magnum钱包存下来。如果你还没有这么做，或者不记得你的私钥保存在哪儿了，那么以下是你该如何做的指引。\n我们强烈建议你应该尽快采取行动。\nMagnum钱包将在将在11月30日下午6:00（格林威治标准时间）停止服务.\n感谢您使用我们的产品。\n因此尽快把你的钱转移到另一个尔格钱包至关重要。\n好在多亏最近将尔格整合进Yoroi， Emurgo开发的卡尔达诺便捷钱包是个非常卓越的替代品。\nYoroi 极易使用。这是一个非常受欢迎，可以作为尔格区块链超级网关的网络钱包。此外，类似于时下流行的浏览器扩展钱包MetaMask以及以太坊的dApp界面，预计将支持未来智能合约的能力。存在若干个主要的差异化特征，比如整页设计，以及为同一个钱包创建多个地址的方式（类似于比特币钱包）。这些都是改善用户体验的好方法，同时还保持了易于入门的特点。\n 当从Magnum进行切换时，需要注意的是：你无法将你的地址直接从Magnum钱包导入Yoroi钱包。这是因为这两个钱包从助记符种子获得地址的方式不同。（从技术上讲，没有什么可以阻止你利用你的Magnum助记符创建一个新的使用Yoroi的帐户，但其对于不同的钱包，比你预想的更加开放。）\n因此，在Yoroi内创建一个新的尔格帐户后，只需将您的ERGs从Magnum发到您新的Yoroi地址，并等待您的交易在区块链上获得确认。\n整个过程只需要几分钟。此外，你也将升级到一个获得支持更给力，且前途无量的钱包。Yoroi将成为尔格生态系统中越来越重要构成要素，为dApps和尔格赋能网站提供支持 –同时也为尔格和卡尔达诺之间的互操作性提供了另一条链。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-12-09-magnum%E9%92%B1%E5%8C%85%E5%8D%B3%E5%B0%86%E5%81%9C%E7%94%A8-%E5%B0%86%E4%BD%A0%E7%9A%84erg%E8%BD%AC%E8%B4%A6%E5%88%B0yoroi%E9%92%B1%E5%8C%85/","subtitle":null,"title":"Magnum钱包即将停用 – 将你的ERG转账到Yoroi钱包"},{"contents":"卡尔达诺的预言机解决方案将发布来自尔格预言机池的数据，并将预处理的数据视为提供给区块链的其自有记录的可信来源。\n8月底，我们宣布预言机池：真是一种针对预言机池的新方法，由尔格扩展UTXO模型所驱动。这些在现有模式上的预言机池的好处是非常可观的，这些好处使创建新型dApp成为可能。\n 现在，卡尔达诺其中一个预言机正在使用尔格预言机池所提供的数据。卡尔达诺的权益池运营商Marek已经为来自尔格预言机的卡尔达尔诺信息设计了一个简单的解决方案，并且通过tx元数据，将其发布到卡尔达诺区块链上。\nNUTS预言机（你可以在nut.link找到）目前提供6个数据流。其针对ERG/美元拥有两个数据源：币虎(Coingecko)和尔格预言机池。这两个数据源也被用于艾达币(ADA)/美元价格。此外， NUTS记录艾达币/欧元以及特斯拉的股价。 此外，NUTS使用受到尔格的预言机池方法启发的融资计划，其将外部数据视为是免费提供的公共产品。NUTS采用了受尔格预言机池方法启发的融资计划，将外部数据视为一个免费提供的公共产品。你可以在推特@stakenuts关注NUTS的动态。\n链互联\n此事大有可为，至少有两个理由。首先，其再次利用尔格预言机池已经完成的工作 – 从而使卡尔达诺得以更有效地发布一个可靠的价格预言机。未来通过该方式分享数据将令两个链受益，因为一旦可靠的预言机搭建成功，任何其他平台可以利用该数据，并且只需支付相对较少的额外管理费。\n其次，这提供了在两个平台之间构建互操作性的第一步。卡尔达诺和尔格目前就相同加密货币分享相同的数据源。这为更大程度合作和跨链互动打通了道路，强化了两个链的联系。\n最终，该功能可能驱动复杂的金融去中心化解决方案，诸如拥有跨链流动性池的尔格-卡尔达诺原子互换，并且定价由双方共同达成的预言机数据所决定。虽然还有很多路要走，但它的确展示了未来有一天可能会是什么样子。\n与此同时，请持续关注预言机池的最新动态以及负责开发卡尔达诺与尔格之间互操作性Emurgo的进一步研究成果。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-12-09-%E6%9C%9D%E7%9D%80%E4%B8%8E%E5%8D%A1%E5%B0%94%E8%BE%BE%E8%AF%BA%E9%A2%84%E8%A8%80%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%93%8D%E4%BD%9C%E8%BF%88%E5%87%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5/","subtitle":null,"title":"朝着与卡尔达诺预言机实现互操作迈出的第一步"},{"contents":"作为Emurgo研究部以及Emurgo 与尔格基金会新合作的一部分，我们已经发布了一款名为Oracle Pools 59的新产品。这是预言机的一个全新模型，其利用了UTXO系统的一些主要优点。我们将首先将预言机池应用于尔格之上，更多细节将在未来几周内发布。\n请在此处点击研究报告全文（英文版）：https://github.com/Emurgo/Emurgo-Research/blob/master/oracles/Oracle-Pools.md\n预言机 池图\n人们也一直想知道ChainLink与预言机池之间有什么区别，为此我为那些感兴趣的人整理了一份清单：\nChainLink 与预言机池之比较\n预言机池在资金/支付/权益方面采用区块链基础加密货币。这意味着他们不要求任何人购买或使用诸如LINK等额外代币，其不会为终端用户或预言机自身带来任何价值，反而使普及变得没必要的复杂。\n根据设计，预言机 池将时间划分为预言机 必须在其内停留的时段。这为建立一个更强有力的激励机制以确保数据源按计划及时更新，降低共谋的利润空间，从而实现更值得信赖的实时数据更新服务。\n 同样，时段提供了一个进行约束的完美方法，如权益削减（预言机要想加入池必须拿抵押品才能加入）。目前ChainLink 聚合器根本没有这个功能（只有承诺会落实），而且其设计使编码变得更具挑战性。预言机池是专门设计用来提升预言机数据可靠性的，因此激励约束完美契合。我们已经开始编写非正式规定（很快也会有合约），使其成为可感知的现实，而非仅仅是某人头脑中的创意。（同样，所有权益都在区块链的原生货币之中，而非在诸如LINK这样的自定义代币） 预言机在池中的工作是获得与保证外部数据能够及时发布到区块链上。这是一项有实际价值的工作，并使非数据源的第三方成为真正有价值的参与者。这是一个不存在于ChainLink的预言机时段设计结果。因此对于数据处理，ChainLink预言机实际上是无用的中间商，简单地削减,在预言机池的预言机本身执行相当于一个及时的送货服务。因此对于实时数据更新而言，ChainLink 预言机实际上是过来分一杯羹没有用的中间商，在预言机池内，预言机自身提供的服务相当于及时配送服务。 预言机池有多种合并治理的方法（ChainLink没有）。此外，预言机池治理非常灵活，比ChainLink被动声誉系统拥有更强的影响力。这意味着预言机池可以使用内部治理，个人预言机（其全部通过博弈理论激励来作为行为指导，以赚钱为目的）对参数/预言机清单进行投票，或者也可以采用将责任分发到大量DAO成员的外部治理DAO。由于预言机池使用寿命很长，因此不需要外部声誉系统，相反，可以通过治理机制采取直接行动，以立即提升数据质量并剔除不良参与者。这种直接的方法提供了直接影响，其对终端用户的影响更大（此外如果希望，可以在此之上增建誉系统，如果任何预言机被踢出一个池，那么他们的全球声誉也会下降）。 预言机池提供更大的sybil 攻击抵抗与一般保证，因为池中个人预言机部分为了推出他们的预言机池自愿协调并聚在了一起。ChainLink针对预言机更为个性化的方法与竞标流程绑在一起有点类似于聘请没有忠诚度的雇佣军/流氓打手，并且只要形势对他们有利，他们随时都可能叛变（并且在这种情况下，你无法判断你雇佣的不同流氓团伙是否和/或同一个人里应外合）。这么来看，预言机池可以被视为是彼此认识的预言机合作社，并将激励措施与共同目标进行统一。他们极有可能如预期执行任务，但如果他们不能，就会采取抑制和治理措施，以确保他们受到严惩与开除。这是如何选择预言机核心理念的转变，专注于使用竞争性预言机池之间的市场态势，而非竞争性个人预言机之间的市场态势。籍此为最终用户提供了更多的保证。 由于有扩展后的UTXO，我们可以轻松建造任意大型预言机数据点秘密分层结构，其使拥有池中池成为可能（继续向更高层次进发），从而以牺牲价格/速度为代价提高准确度。ChainkLink的设计不太可能，因为预言机本质上是唯一的参与者，没有将聚合器进行聚合，并且拥有该规模的设计。此外，缺乏UTXO模型使这种层级完全无法正常工作。数据沿着层级结构向上积累以及资金自上而下分散都处在执行起来更为复杂的数量级（并且可能更容易受漏洞/错误的伤害），转化为更高的成本，并使其在基于账户的模式下是否可行成为一个悬而未决的问题。 此外，任何人都可以在不付出额外成本的情况下访问预言机池产生的数据点（在具有数据输入的UTXO系统上）。这意味着他们可以为区块链上任何dApp轻松使用，从而使预言机池更像一个公益事业。因此即便两个人（我的意思是说非洲那些无法为预言机数据明确付费的人）之间的小型“p2p”智能合约依然可以访问核心预言机实时数据更新服务。这是一个最最新潮的事物，这在我的书里非常精彩。 这对于dApp使用来自单一tx多个预言机池的数据点来说是一件小事。允许在合理定价的同时出现更复杂的DeFi dApps。 由于预言机池数据点在产生后可以被链上的任何人使用，这意味着区块链上的每个人都有向所说预言机池提交资金的动机以保持实时数据更新服务可以继续。由于有UTXO模型，这可以轻而易举地以被动方式做到，dApps要求用户在其tx上创建一个前往预言机池，并且含有少量资金（ex. 相当于0.05美元）的额外输出UTXO。例相当于0.05美元)。对于这么小的金额，用户几乎无法察觉到，但其迅速积累，并且为预言机池提供了源源不断的资金流以确保其继续平稳运行。因此预言机池为我们提供了全新的经验，用户为预言机池被动提供资金，从而生产实时数据更新服务，基本上成了一个公益事业。 由于预言机池寿命很长，并且容易资助，区块链生态系统可能会专注于建设拥有现成的激励/约束机制的主要永久性预言机池，以及针对参数的内置治理 + 进入预言机池（其协助确保所涉及的参与者能够抵御 sybil的攻击）。因此我们可以创建区块链上任何人都可以使用的值得信赖的预言机实时数据更新。这是一个与ChainLink希望建的非常不同的版本，并且在我看来，要激动人心的多。我们的方法是更有针对性地/更有主见的，并且加上扩展后的UTXO模型，提供多项完全新的好处。  ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-10-03-%E9%A2%84%E8%A8%80%E6%9C%BA%E6%B1%A0-%E4%B8%80%E4%B8%AA%E5%85%A8%E6%96%B0%E9%A2%84%E8%A8%80%E6%9C%BA%E6%A8%A1%E5%9E%8B/","subtitle":null,"title":"预言机池 - 一个全新预言机模型"},{"contents":"通过Emurgo-尔格合作制定的新计划可以将预言机池 – 这个区块链核心基础设施– 像公共服务那样加以运行，任何dApp和开发者在使用的时候都可以免费获得。\n预言机是DeFi基础设施的关键构成。其是区块链与外部隔绝世界以及来自真实世界的数据之间的桥梁，因此对于DeFi实现其充分潜能至关重要。主要运用场景的整合，包括稳定币和贷款平台，仰赖与用途相契合的预言机。\n当前预言机的执行情况还不太理想。Emurgo-尔格合作的第一批项目中有一个项目是研究预言机池的：这是一种将数据从外部世界带入区块链的新的方法，并且随时可供任何dApp使用。\n当前安装的不足\n预言机已经为以太坊上的许多种去中心化应用打下了基础，并且通常采用以下方式工作：\n预言机获得数据并将其提交回通过另外交易调用它的合约。  虽然其运行相对良好，但普通预言机基本上可以被看作是采用“付费游戏”模式的私人服务。由于这对于许多应用情形显然是不够的，因此发展了实时数据更新概念以提升用户对于一般定价信息的体验。\n然而，以太坊上的当前实时数据更新服务倾向于以一种非常可信的方式实现。其缺乏一种为数据可靠性提供保证的通用方法，包括数据的准确性及其发布时间表。此外，此类方法通常没有能够令其长期可持续的明确去中心化融资机制，而是依赖中心化参与者提供出资。\n尔格和Emurgo认为预言机过于重要，以至于不能通过这种方式加以限制。其应当是DeFi行业的公共基础设施。通过合作开发的预言机池模型来解决这一需求。\n预言机池的设计\n尔格的UTXO模型为之前无法获得的预言机系统提供好处。预言机池的作用是实现数据提供的去中心化，确保流程和数据本身更为可靠。\n预言机池最简单的功能是将时间分成固定时间段（如6小时），其在被细分为若干区块（如：180个两分钟区块）。池中的预言机组就数据源达成一致，并且每个数据源在其自身UTXO中的区块链上发布其数据点\n在时段终点，在消除读取每个数据点UTXO最终交易异常值后，再将这些数据点进行平均。这导致预言机池产生一个新的最终数据点，并向下一个时段移动。\n这一点理解起来并不特别复杂，但却奠定了坚实的基础。需要注意的一个关键因素是整个过程都是在链上发生的。此外，使用UTXOs使增加激励与治理机制成为可能，使预言机池和数据提供在复杂度和灵活性方面比以往有非常大的提升。\n建立在基于UTXO预言机池基础之上\n如前所述，可以对这些数据池实施奖惩措施，以确保其所提供数据的质量和及时性。预言机提供了诸如ADA、ERG等一定数量的抵押品以参与池。如果其未能妥善完成工作，会将这些币种会从其余额中移除（“权益削减”），例如：如果他们无法收集其他预言机的数据点，如果它们提交了一个错得离谱的数据点（一个异常值），或者它们没有及时提交数据点。这将确保预言机能够很好地完成自己工作。抵押品是区块链的原生货币，而非另外的代币，从而令问题简化，提升了经济激励。\n该模型还使治理投票能够确定预言机池的主要参数。治理社区可以决定诸如时段多长时间等变量， 预言机发布有效数据点能够获得多少报酬，它们所需要的最低抵押品，每个池的预言机数量等。具有高度灵活性，可以根据当前需要对参数进行修改。可以邀请新的预言机入池，其他移除等。\n该模型直接包含了严格的发布时间表（时段）和治理，诸如 Chainlink等项目则没有。预言机池实际上变成了多个迷你DAOs，其旨在提供最佳服务，并且可以根据其在自由市场所提供的服务进行竞争，从而提升每个人所使用数据的整体质量。\n支付模型\nUTXO模型意味着结果会被发布到区块链上，任何人只要支付交易费都可以使用。这并非标准的付费游戏方法：dApps可以随意访问数据。此外，即使在预言机池之上构建了更复杂的协议，对预言机池数据的访问通道也可以清晰地复制扩展，并且没有额外成本。（如等级制度，或者时间加权平均）。\n预言机池是由长期使用它们的dApps支付的。尽管每个人都可以使用预言机池，并且每个使用它们的人都有为它们提供资金的动机，其花费微乎其微– 只占某一dApp额外费用的一个很小比例。预计这些预言机池支付将在主要dapp上完成，因此要确保预言机池始终拥有运行所需资金。\n诸如稳定币、钱包、去中心化交易所、贷款协议等大型旗舰应用程序将会以主要区块链公司运行自己的节点大体相同的方式向主要预言机池付费，这是最有意义的。\n借用一句商界套话，这是他们业务的一部分，也是他们企业社会责任的一部分。这是他们保证获得所需数据的方式，以帮助保持生态系统健康，并表明他们在DeFi行业保持距离这一问题上是认真的。与此同时，预言机池被设计成即使是小的参与者也可以运行自己的系统，如果他们能够找到足够多的用户，他们也可以有自己内置的融资机制。\n池模式意味着在不同池结构范围内所支付的资金可以被有效花掉。其可能设一个池中池，几个预言机池将数据加总，然后将这些结果放到池中计算平均值。支付到最顶部的一个池中，其根据它们的可靠性层级将资金支付到下一个池中，这些池将资金分配给它们中最可靠的预言机。主要好处是对用户来说比较简单，因为只需要向最顶部的池子支付一笔款项。\n利用签字数据还有个范围– 必须是来自诸如大型交易所等值得信赖实体的数据。这些实体可以将签字数据提交到‘首先发布’池，在那儿资金被分配给第一个预言机，以将数据记录到区块链上；由于他们值得信赖，因此平均计算过程也就不那么必要了。也可以是一些将部分已签署的数据和部分未签署的数据进行加总的池子，真是两全其美。可以将已签署和未签署的数据点放到一个池子中，然后再打包成一个单一的数据点，仍然可以通过向最顶部池支付的方式，简单明了地进行付款。\n这是来自Emurgo-尔格合作的首个落实：这是打造基于UTXO的DeFi生态系统的第一步。 还会有更多落实出台，有关新开发的承诺令人感到振奋人心。\n欲了解更多背景信息，请观看Emurgo研究员Robert Kornacki 对预言机池所做的说明**。**\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-09-28-%E5%B0%94%E6%A0%BC%E7%9A%84%E9%A2%84%E8%A8%80%E6%9C%BA%E6%B1%A0%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AF%B9%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88/","subtitle":null,"title":"尔格的预言机池以及其对生态系统意味着什么？"},{"contents":"与DeFi的几乎所有其他领域一样，尔格平台对NFTs采用了一种不同的方法，其提供了一些有趣而特有的使用情形与好处。\nNFTs似乎将成为区块链的下一个主要前沿领域。在这一年里，加密已经成为一种被接受的、实际上是主流的（如果仍然是新的）对冲通胀以及储值的手段。在过去的几个月中，作为区块链使用情形DeFi的出现同样令人印象深刻，不管还有哪些问题需要解决。\n在这两者的基础上，NFTs是一种具有吸引力的新资产类别，其提供的功能是现实世界用户所熟悉的，但远远超出了以往任何可能的功能。\nNFTs（非同质化代币）是独有的和不可分割的区块链代币。它们可以用来代表和证明数字产品的所有权，比如艺术品、游戏中的物品或角色、虚拟交易卡等等等等……因为NFT可以用来代表最终所有权，其允许用户交易数字物品，并以加密方式保证出处。\nNFTs正成为非常大的业务。对于区块链来说，这是一个新兴的细分行业，但是一个预计会高速增长的行业。可作为代币物品的数量使得一位分析师认为，这个价值超过1亿美元的加密使用情形有朝一日将成为一个万亿美元大市场。\nUTXO NFTs\n目前，大多数NFTs都托管在以太坊上，而像Rarible这样的大型市场允许创作者出售他们的作品，并且其他用户可以在二级市场上购买与交易这些作品。随着交易费用的飙升，与制造与交易NFTs相关的成本如今可能高得令人乍舌。不管其他优点和缺点是什么，使用一个交易费用既低，又有长期扩展计划的平台是有好处的。\n然而，正如尔格扩展的UTXO模型为预言机和诸如智能合约等其他核心区块链基础设施提供了一种不同的方法一样，其也为NFTs提供了创新。\n一个有趣的功能是可以将尔格用以创建工作量证明支持的NFTs。对于大多数NFTs来说，用户只需生成一个带有所附代币合约的UTXO。但是，对于矿工而言也可以创建特殊的NFTs，新生产的代币的ID就是Coinbase交易的ID。这有所有种类的潜在使用情形，但其核心思想是矿工在区块挖矿时，有机会创建一个特殊的NFT。虽然可以通过常规智能合约创建任意数量的NFTs，但是只有有限数量的基于工作量证明的NFTs可以存在。\n它的一个小应用正在创造值得纪念的事物：例如，一个纪念区块链第100万个区块的NFT。区块奖励是同质化的，可以像其他硬币一样消费，但是NFT是独一无二的，其只能在区块被挖掘时生成一次，并且只有将该区块添加到区块链的矿工才能这样做。\n不可伪造身份\n还有其他使用扩展的UTXO模型的NFTs应用程序，包括推进新一代复杂的dApps。例如，dApp创建者可以生成一个与地址和智能合约相关的NFT。尽管任何人都可以使用该合约，甚至可以使用该地址的私钥创建交易，但NFT的所有者仍然保有管理权或其他特权。\n假设你创建了一个非常成功的交易所dApp，其只需向所有人支付很小比例的交易费 -由该NFT的所有人指定。这种代币以及未来的收入现在可以被转让和出售。该代币还可以通过二级智能合约来进行管理，其将收入在代表股东的100个代币中进行分割。可以用NFT对dApp进行更新，或者在必要时关闭 - 无论什么条件被加密其中。关键是NFT提供了有保证的、不可伪造的身份证明。\n这些使用情形仅仅触及尔格上NFTs的表面。我们期待看到这个生态系统会如何发展，无论是在尔格平台上，还是在更广阔的NFT领域。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-10-03-%E6%9C%89%E5%85%B3%E5%B0%94%E6%A0%BC%E7%9A%84nfts/","subtitle":null,"title":"有关尔格的NFTs"},{"contents":"正如最近的一篇博客文章所探讨的那样，DeFi – 即金融去中心化 – 可能而且将会以任何开发者和市场认为合适的方式加以运用。 其具有开放、去中心化系统的性质。你无法阻挡，说我们不应尝试有着非常充分的论据。为了限制DeFi的任何元素，至少在协议层面，将引入中心化和单点故障，从而通过对其进行误保护而扼杀了核心创新。\n但“去中心化”被广泛误解。首先，其并非一个二元问题：一个项目既非去中心化，也非中心化。去中心化存在于一个频谱之上。区块链“网络”的一个节点是中心化的；在其网络上拥有数千节点 的比特币通常被视为是去中心化的。 中心化与去中心化之间的门槛的点到底在哪里？ 是10个节点、100个节点还是1,000个节点？\n许多‘新的’ DeFi协议简直就是现有dApps的克隆体，使其更像庞氏骗局和或YIP骗局。更糟糕的是，用户在未经审计的情况下就在这些智能合约中投入数百万美元，就如同Yam Finance那样，导致了出现令其代币价格跌到零的漏洞。\n其次，去中心化存在不同的类型。区块链网络可能是去中心化的，但是开采基础设施可能并非是去中心化的，特别是如果几个池的哈希率达到51%。如果交易所或者活跃的开发者非常少，这些也是中心化的形式和潜在弱点。\nDeFi的近期失败\n最近几周我们已经看到中心化的其他形式以及DeFi领域的失利，这意味着很大比例的DeFi完全无法被真正视为是去中心化。\n至少两个最近的DeFi项目（一个是另一个的分叉, 并且很显然，利用所承诺不太可能实现的收益来吸引高产农民），包括“无限造币厂”功能，该功能使开发者得以实施退出戏法，在最赚钱的时候，卷款逃之夭夭（如果没有时间锁定的话）。当下UniSwap臭名昭著的克隆体SushiSwap显然也遭遇了类似的退出骗局，其创始人Chef Nomi从dev fund拿走了1,400万美元 – 后来不知是出于真心懊悔，或是演戏又把钱退了回来 。\n对中心化的穷追猛打\n当DeFi含有任何上述单故障点的时候，DeFi也就不再是DeFi 了。“去中心化”技术远不局限于区块链。采用区块链和智能合约对于DeFi只是入门级要求：是必要条件，而非充分条件。\n如果协议包含后门（无论是像“无限造币厂”功能(Yuno)故意嵌入的，还是像Yam Finance的变基漏洞那样不小心退出的），那么该协议不可能被视为是去中心化的。 如果个别开发者或者小团体控制着大量资金，如果资金被盗，该项目将会毁于一旦，因此其也不是去中心化的。\n从一开始就实现充分的去中心化或许是不可能的，但是重要的是非必要的中心化 –以所有形式 – 尽快被消除。\n这正是尔格希望做的：在去中心化区块链基础设施上打造去中心化应用，并且拥有强大和独立的开发者社区、可以安全运转并且易于审计的智能合约，并且利用例行联合签名来保护社区拥有的资金。\nTo find out more, join the Ergo Discord or Telegram group.\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-09-24-defi%E9%87%91%E8%9E%8D%E4%BD%86%E5%B9%B6%E9%9D%9E%E6%80%BB%E6%98%AF%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/","subtitle":null,"title":"DeFi：金融，但并非总是去中心化？"},{"contents":"尔格的零知识财务管理基金使用户得以轻松创建联合数字签名，为资金支出提供定制条件，同时确保所创建地址的签字人不被发现。\n零知识(ZK)密码学提供了许多强大的使用情形。零知识操作的好处是其不但安全，而且可以保护隐私。\n假设你在公园的地上看到一部智能手机。旁边一个女的说这手机是她的，但你不相信。或许她只是想要电话。她可以告诉你手机的解锁密码，但如果那样，你就会获得她作为手机主人的信息，但她不希望你知道。所以，你闭上眼睛，手拿着手机，当你再睁眼的时候，手机已经解锁了。她已经在不泄露个人敏感资料的情况下证明她才是手机的主人。这就是零知识证明的一个简单的举例。\n区块链领域的许多应用极具吸引力。鉴于比特币区块链上通常三分之二为多签名地址，因此要想进行资金转账，其交易必须获得该地址的总共三名私钥持有人中的任意两人的签字。其比单签名地址要安全得多，但缺乏隐私保护。任何人都可以查看区块链，知道到底是谁签署了交易。\n凭借零知识签署，没有人知道谁签署了该交易–只知道达到足够多的私钥签署了。\n尔格的西格玛协议非常适合创建组合式无知识签名。换言之， 一群用户可以聚在一起，按照他们规定的条件创建一个地址。例如，5个用户可以创建一个地址，他们中的任意3个人需要在这个地址上签名才能进行交易，或者条件可能更为复杂。由7个人组成的创业团队可以创建一个地址，必须获得首席执行官和首席财务官两个人的签名才能释放资金，否则必须获得任意5个钥匙持有人才能签署交易（如果首席执行官或首席财务官中有一人无法履行工作，会提供保险政策）.\n尔格一直是一个社区驱动的项目，我们也一直得到开发者的大力支持，他们中的很多人都宁可隐姓埋名。我们的一位匿名开发人员率先开发出一个用户友好的界面，可以很容易地组成联合支出团体，其规定要想进行交易，签字人必须达到一定数量（因为早前这一过程非常复杂，即便对于技术用户来说亦是如此）。\n用户‘anon_real’ 写道:\n该项目包含两个独立的应用程序、服务器和节点。\n每个可以提出想法和要求团队提供资金的人都可以访问该服务器。\n另一方面，每个团队成员都必须建立客户端应用程序，其负责与其秘密、节点、浏览器和服务器进行互动，为批准的建议提供必要的证明。\n如果建议被标记为完全同意（根据团队签名，已经收到足够数量的批准），那么客户端应用程序将在不需要成员任何干预的背景下创造必要的证明和交易，\n你可以在尔格平台上找到有关零知识财务管理基金的深度讨论。\n除了在尔格上安全花钱以外，该应用程序还有很多使用情形。例如，一个类似的界面可能是去中心化公钥基础设施 (dPKI)的基础：这是一种创建与管理公/私密钥对以验证用户及设备的手段，但没有在可信公钥基础设施(PKI)设置中存在的中心化故障点。\n非常感谢anon_real，我们希望看到在尔格社区使用零知识财务管理基金！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-09-24-%E5%9C%A8%E5%B0%94%E6%A0%BC%E5%AE%A3%E5%B8%83%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%B4%A2%E5%8A%A1%E7%AE%A1%E7%90%86%E5%9F%BA%E9%87%91/","subtitle":null,"title":"在尔格宣布零知识财务管理基金!"},{"contents":"Robert Kornacki\n我想正式宣布预言机池是有生命的，其在主网上运行，所有密码+ 详细指示可供阁下启动/运行你们自己的，并且我们拥有一个由DeadIT所创建的目前在浏览器上安装的漂亮前端。\nhttps://explorer.ergoplatform.com/en/oracle-pools-list\n尔格预言机池能否被用在以太坊项目上？\n可以在以太坊上开发与部署一个类似的系统，但是所有的数据都发布在尔格区块链上，这样所有的尔格用户都可以使用。\n所以没法将数据从尔格区块链转移到以太坊区块链上？\n最终，如果以太坊采用非交互式工作量证明的证明（NiPoPoW），但是其在财务方面没有意义。\n卡尔达诺情况如何？\n将独有的数据从尔格区块链发布到以太坊或卡尔达诺比发布预言机数据更有意义。我们目前在后台研究与卡尔达诺的交叉链兼容性。\n并且这些预言机池对于任何人希望创建的任何dApp来说在链上是完全可用的。用预言机池非同质化代币身份作为参考，来寻找最新预言机池UTXO，你可以立即将预言机数据用于你的dApps。\n因此需要不断向预言机池添加激励机制，这意味着用户走的时候需要付费，或者他们进行大额汇款，并且随着它们的使用而逐渐耗尽?\n好问题。思路是通过UTXO模型，大型dApps可以强制用户就单一输出支付一个非常小的费用比例，该费用将自动打给预言机池。\n正因为如此，经常使用的/受欢迎的dApps通过使用为主要的预言机池提供资金支持，并且几乎没有人最终会有成本的感觉。\n对于更为专业的数据，池可能需要更直接的资金支持，但对于诸如Erg/美元这样的关键数据点，这可能相当于为每个人可用的核心基础设施。\nUniswap协议大概如何收费以支付LP?\n的确，但是在UTXO模型中，其可能会更通用、更便宜、更容易实现的多。\nRobert.. 这些对卡尔达诺有什么好处呢??\n好问题！以下是我在Reddit就此问题所写的回复:\n当然，让我来帮助澄清一下。本质上，当外部预言机数据被发布在链上时，其需要在交易中以非常精确的方式对其进行加密。此外，预言机池有许多不同的移动部件，其需要发布交易，以便在池协议的不同阶段之间进行移动。\n因此，预言机核心是一款创建所有复杂交易的软件，其在链上发布数据，并在链上运行预言机池协议（诸如平均数据点）。\n当前预言机核心是就尔格中的基于UTXO系统而设计的，其在很多方面是与卡尔达诺中的基于UTXO系统非常相似的。\n我们在Emurgo同时支持卡尔达诺的ADA和在即将在Yoroi推出的尔格ERG，专注于移入智能合约和DeFi支持，特别是Gougen即将推出。因此，我们目前投入了大量资源开发整个生态系统所需的主要基于UTXO的智能合约基础设施，首先是已经推出并且投入运行的尔格，很快也会应用在Gougen上。\n预言机池支出意味着什么？你们是否为资助预言机池而获得回报？\n每个提交数据点的预言机都可以从他们的工作中获得回报。预言机池支出是指预言机在每个预言机池数据点完成或发布时获得的毫微Erg金额（Ergs的最小计量单位）。因此你如果看一下扉页 https://explorer.ergoplatform.com/en/oracle-pool-state/adausd你可以看到预言机的支出价格为2500000 ，发布时间为60分钟（30个区块）。因此在这个池中，预言机池每30个区块支出2500000。\nDaedalus钱包能否可以在获得权益回报的时候，利用ADA预言机增加当前价值\n也是/也不是。当前预言机在尔格区块链发布数据，因此其要求Daedalus同时支持尔格拥有类似设置。\n通常来讲，对Daedalus自身来说通过http请求获取定价数据会更容易，而且在技术上是可行的。一旦我们有了可行的卡尔达诺预言机（并且由于Daedalus是一个完整的节点，它将扫描所有txs/区块，因此数据是可用的，所以它肯定可以做到）\n尽管听起来Yoroi钱包非常可行，是这样么？\n哈哈，答案还是也是/也不是。为了获取UTXO系统中的数据，你需要扫描UTXO集合，因此你需要自己的节点。像Yoroi这样的轻钱包就没有，因为如果每个人都批量发送Emurgo全节点，并且强迫我们为每个人的UTXO集合扫描支付，那么理论上会耗费无数的金钱。\n您是否能想象一下IOG或Emurgo将尔格区块链用于诸如稳定币或者去中心化交易所的服务/产品？\n我们（Emurgo）目前正在与尔格基金会进行合作以在尔格上创建稳定币。我们还在研究直接互操作性，以及将我们开发的dApps部署在尔格以及卡尔达诺上在多大程度上是可行的。\n由于Sigma协议，尔格具有卓越的隐私特点，因此在未来我们有很大的机会可以成就无限的互操作使用情形，您可以持有包装的Ada并将wAda用于保护隐私的智能合约。\n我认为出现在尔格区块链的相同稳定币也将会来到卡尔达诺的区块链。未来我们或许能看到尔格和卡尔达诺进行彼此交谈？\n我们投入了大量的精力，并且开始就如何使其变为现实与IOG做更多讨论（就区块链之间的相互交流）。\n因此，在这种情况下，唯一的限制是针对请求提供各类数据源以使其有用？\n由于预言机池存在简单分层结构，的确存在这种情况。我们还在研究将有符号数据和无符号数据混合在一起。\n例如，您可以用池子从CoinBase获取有符号数据，然后从其他无符号数据源获取其他数据，从而降低损坏任何一个数据源的机会。\n除了我在最初文章中所规定的简单层级结构以外，我花了更多时间思考在预言机池上搭建一个更为复杂的计划，其可以以不同方式运用比这多得多的博弈论，也许我们会在年底前发表一些此类内容的文章。\nEmurgo从哪获取进行这些开发的资金?\nEmurgo 是打造卡尔达诺的创始公司之一，并且目前正在与尔格基金会合作，也使我们能够在这一生态系统里进行开发。\n近期我们会否看到尔格在更多的交易所上市？透明度与流动性是目前的痛点。\n我们（尔格基金）一直在与各大交易所保持沟通。\n我喜欢这一链下到链上的隧道技术\n这完全是题外话，但我有一个超级未开发的业余爱好，我认为当链下分布式信息网络与区块链之间互操作性与区块链整合到一起的时候，其将是一个重大突破。\n我的假设是Yoroi钱包最终将支持尔格代币，对么？\n是的，在不远的将来会把Erg支持功能加入Yoroi钱包。不过尚未有具体日期，敬请留意！\nRobert曾经提过一句，除了投机炒作以外，什么是尔格生态系统升值的主要动因？这是我朋友问我的头号问题。\n我认为，一个清晰的未来愿景：在新模式（UTXO）上拥有内置隐私能力，无需批准的DeFi提供了用以优化与提升普通用户在加密与DeFi方面的整体体验的能力。\n很显然我们还没有达到为普通用户提供流畅轻松体验的地步，但某些你在UTXO所做的事情是不可能的（或者说不容易/不经济的），就好比让任何其他人花你“所拥有的”UTXO。\n你曾说过预言机池成本更加低廉，并且消除了中间商，但是有传言说门限签名正在登陆LINK，并且将削减99%的tx费用。这对其是否有任何有效性？\n我们在尔格已经拥有了门限签名，因此如果那种方法好很多，我们可能会做相同的事情。\n这也就是说链上提供很多好处，落实诸如权益削减等激励/抑制措施，其不可能与门限签名在链下进行。我们在尔格不存在此类tx拥挤，并且未来计划就扩展开展侧链研究，因此我们在链上这么做会获得多得多博弈理论好处，并且现在其都很便宜。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-10-08-robert-kornacki-%E5%85%B3%E4%BA%8E%E9%A2%84%E8%A8%80%E6%9C%BA%E6%B1%A0%E9%97%AE%E7%AD%94%E7%8E%AF%E8%8A%82%E6%96%87%E5%AD%97%E7%A8%BF/","subtitle":null,"title":"Robert Kornacki 关于预言机池问答环节文字稿"},{"contents":"每个人都在谈论DeFi。很少有人问DeFi到底应该是什么样子。因此，尔格对这个行业的未来有一个愿景。\n2020年正在成为去中心化金融成为主流关注的一年，其方式与比特币和区块链2016年和2017年方式相同。仅在今年7月，总锁定价值 – 即对DeFi dApps智能合约承诺投入的资金金额 - 从20亿美元翻倍至40亿美元，这在很大程度上是由Compound分发COMP治理代币所驱动的。\n此刻DeFi风靡一时，有几个知名项目率先映入我们的眼帘。但是，当加密货币世界的注意力被DeFi的短期机会吸引后，很少有人会谈论DeFi到底是什么，并且更少的人会谈论它应该是什么。然而，在搭建像尔格这样的DeFi平台时，这正是我们必须要问的问题。\nDeFi不喜欢限制\n在讨论DeFi应该是什么的时候，很容易陷入引入任意条件和限制的规范性陷阱。但是那不是区块链的意义所在。正如我们看到的比特币和区块链一样，总体来说，那是一个思想的自由市场，没有什么是不能讨论的。可以说（尽管不是特别有帮助）DeFi应该可以“提供了一切可能”。\n与区块链相似，DeFi为财务流程带来了透明度、不变性和效率（通常包括速度和/或成本）等优势。但就我们所认为这套新技术应当能提供的内容，以及去中心化金融可以为常规金融体系带来的内容而言，我们有必要将谈话重心放在部分迄今为止依然被忽略或未充分代表的重点领域：隐私、可扩展性、互操作性以及去中心化。\n1. 隐私\n正如埃里克•休斯(Eric Hughes)在1993年《一名密码朋克的宣言》(Cypherpunk’s Manifesto) 所写的那样，“在电子时代，隐私对于一个开放社会是必要的”。对于财务隐私来说，这一点再正确不过了。隐私必须是DeFi的一个内置特征，而非一个外挂额外的或令人向往的特征。其必须是一个整体。\n但是，休斯继续说的，“隐私是有选择地向世界展示自己的力量”。在隐私与合规之间、透明与匿名之间，总需要找到一个平衡点。大规模普及DeFi必须具有可审核性以及使其得到落实的监管审批。\n由于零知识证明所取得的最新进展，如需要，尔格既可以提供隐私，也可以提供透明度。该平台的西格玛协议提供了强大、可定制的加密技术 - 同时，如有必要，具有选择性披露信息的能力。\n2. 可扩展性\n每秒处理数千宗交易的能力也是一个蓬勃发展DeFi行业不折不扣的特征。实现上述目标比采用何种方式实现更重要；在实际操作过程中，有许多不同的方法可以选择，不同的用户和协议选择其所青睐的的方法。\n例如，尽管我们看到了侧链和子链的崛起，但现实情况是交易所依然是大量用户进入区块链世界的一个门户。热门交易所在不断整合DeFi功能，使其庞大的用户基础得以从他们的个人帐户进入，无需与协议进行直接互动。\n虽然从安全的角度来看，这可能不太理想，但一个简单的事实是中心化服务并没有过时，由于其所提供的优势，其正在对去中心化的技术进行整合。尔格有自己的规模扩大化方法，但我们不能也不会忽视企业在推动用户普及方面的重要性。\n3. 互操作性\nDeFi的其中一个主要优势是可组合性：利用已建立的dApps和代币的网络效应，从现有组件搭建新应用程序的能力。这是过去一个月总锁定价值(TVL)出现爆炸性增长的主要因素之一。\n但可组合性目前有其界限。跨平台可组合性目前是不可能的。即使作为互操作性第一阶段的原子交换 – 也还处于起步阶段，尽管尔格正在建设一个基于原子交换驱动的去中心化交易所（DEX）。\n完全互操作性意味着用户能够在一个平台上执行智能合约，并与另一个区块链进行完美互动。这使真正无摩擦跨协议互动成为可能，也是流动资金在整个DeFi世界实现完全流动所需的。此时，应用程序与区块链无关，平台实际上更像是访问dApps功能的编程语言。\n4. 去中心化\n最后，特别是在可扩展性和互操作性的背景下，我们不能忘记去中央化的重要性 - 这一直是尔格严肃对待的事情。\n当然DeFi是去中心化的 – 但是有不同类型的去中心化。作为几乎所有主要DeFi dApp的大本营的以太坊只是一个平台。\n以太坊的开发者正在制定一项扩展计划，但是即便这个计划能够成功，其依然只是一个区块链。我们是否应该将我们全部的资金托付给一个网络？如果出现严重漏洞或者被人利用怎么办？\n互操作性不仅能够实现跨链流动性。其对DeFi的去中心化基础设施进行去中心化，增加了冗余层和安全性。在这一过程中，其强化了作为生态系统一部分的每一个区块链，创建一个整体，而不仅仅是将各部分加总。在较大区块链依然遭受双重支付攻击和严重重组，以及在持有价值数千万美元的智能合约中发现灾难性缺陷的时候，我们不能假设一个区块链将或应该对所有合约做出裁决。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-10-06-%E6%89%93%E9%80%A0%E5%B0%94%E6%A0%BC%E6%88%91%E4%BB%AC%E5%AF%B9defi%E7%9A%84%E6%84%BF%E6%99%AF/","subtitle":null,"title":"打造尔格：我们对DeFi的愿景"},{"contents":"DeFi是区块链技术的下一个主要前沿领域 – 但是，当前市场兴趣的激增对尔格又意味着什么呢？\n我们面前有关区块链技术的描述正在不断演变。智能合约平台的使用情形正在日渐清晰，被装进一个名为DeFi（或者叫“去中心化金融”）包罗万象的术语中。\nDeFi服务通常很像它们的传统交易对手方，包括贷款和衍生品平台，以及一些更为奇特的服务。然而，与传统的类似平台不同，尽管这些平台是任何人都可以访问的开放性平台，并且利用来自其所托管的区块链的透明度和安全性进行建造。\nDeFi的激增 过去两周新生的DeFi领域出现迅速变化，并且受到贷款平台Compound的治理代币 - COMP推出的催化。DeFi的其中一个内在好处是透明度，此举的影响可以通过诸如DeFi Pulse等网站进行明确跟踪。\nCompound几乎立刻抢占了总锁定价值(TVL)的第一名，将Maker协议挤到第二名。在新的产量农业热潮中，在流动性挖矿的热潮中，随着数万用户蜂拥而至，以利用该平台分发的COMP代币，Compound的总锁定价值在短短10天内就从基线的1亿美元飙升到6亿美元。\n但肯定不是所有人都回来了。在同一时期，Maker协议在Dai利用其Vaults所生成的金额方面创出新高。与此同时，合成资产平台Sythetix的总锁定价值翻了一番。\n这与价值在比特币与代币(alts)之间进行简单洗牌的常规加密货币世界的熊市反弹不同，同时总体走势是下行的。这里还有别的东西在起作用。\n非常规思维 理由可能取决于DeFi平台的另一个内在属性：可组合性。因为DeFi dApps是透明和开放的，其是可以被依赖与适应的，轻易创建新的dApps。然后这些dApps自身可以插入其他应用程序，在一个良性循环的使用中适应和重新部署。\n由于将DeFi世界中不同平台连在一起非常容易，因此Compound的兴起与其他DeFi倡议的兴起也是息息相关的。当边界孔洞很多时，几乎很难将它们视为完全不同的平台。可以在一个dApp上利用、出借以及部署该资产以利用另一项资产目前所提供的好处。\n有证据表明 – 鉴于区块链的透明度– 这正是正在发生的事情。资产可以在一个dApp上进行杠杆化、借贷和部署，以便利用另一个dApp当前提供的优势。和有证据由于透明度的区块链,什么年代发生。DeFi需要一些非常规的思维。与其用自然人竞争术语来看待这个行业，谁是第一，他们比第二名领先多少？这需要进行范式转变，并认识到可组合性意味着默认的协作。这不仅是其所希望的，而且是不可阻挡的 – 在其核心，与DeFi是不可分割的。开放、协作的金融服务。\n对尔格来说，该领域兴趣的激增是一项令人兴奋的发展，并对决定加以确认，以优先考虑多元化的智能合约以及DeFi功能。其同时表明区块链之间有互操作的需求，使任何智能合约协议能够与任何其他协议进行互动。\n尔格正朝着最终实现原子交换的方向前进，其将促进跨平台的交易活动，- 并最终在以太坊和其他区块链DeFi服务中使用ERG和尔格资产，反之亦然。\nDeFi显然是未来几年提供金融服务的重头，并且尔格将为这一领域做出独特的贡献。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-10-06-%E5%B0%94%E6%A0%BC%E4%B8%8Edefi%E7%9A%84%E7%88%86%E7%82%B8%E6%80%A7%E5%A2%9E%E9%95%BF/","subtitle":null,"title":"尔格与DeFi的爆炸性增长"},{"contents":"将在尔格稳定币项目中开展对预言机池的联合研究。\n预言机是金融去中心化(DeFi)的核心要素之一，在相互绝缘和独立的区块链世界与现实世界数据之间提供联系。为了安全有效地执行，dApps必须能够访问可靠的价格数据及其他信息。\n来自尔格-Emurgo合作进行的新研究为解决达成共识的问题以及在区块链上公布数据提供了一种新的方法：预言机池。\n尽管预言机在为dApps提供数据源方面非常重要，但研究显示当前预言机的方案缺乏透明度、问责制和运行稳定性。这使其成为潜在的单一故障点，威胁任何依赖其所运行软件的安全。以稳定币为例，这可能意味着失去钉子的风险，并使其易被攻击和利用。\n预言机池 预言机池的概念是为尔格扩展的UTXO智能合约模型而设计的，尽管高层次概述可在基于帐户的系统中使用（如以太坊）。\n 预言机池是一种试图解决上述问题新模式，同时还提供其他新功能。从保证数据发布时间表、合并博弈理论性激励+抑制因素、嵌入式治理、潜在动态入口，以及构建预言机数据点信任等级制度，该模型释放出许多种可能性。\n 预言机池涉及几个预言机同时运行，其在池中占比各不相同，并根据其所提供数据的可靠性获取付款。（为了确定数据的‘真实’价值，剔除异常值，并且对数据点进行平均计算。）要想参与，预言机需要提供抵押品，如果无法按时提供高质量的数据，可能会被“罚款”。\n因此 – 在工作量证明中，共识方法本身 – 奖励诚实的预言机，同时存在欺诈或不可靠的预言机浪费其资源。\n稳定币 当采用新模型时，其将成为支撑尔格稳定币技术的关键部分。（这将采取算法或担保的方法，而非像泰达币(USDT)或USDC等由强制性法令支持的币种）\n将在适当的时候发布有关新稳定币的进一步细节，预计新项目将在2020年晚些时候推出。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-09-07-%E5%B0%94%E6%A0%BC-emurgo%E8%81%94%E6%89%8B%E4%B8%BA%E9%A2%84%E8%A8%80%E6%9C%BA%E5%88%9B%E9%80%A0%E4%BA%86%E6%96%B0%E7%9A%84%E6%A8%A1%E5%BC%8F/","subtitle":null,"title":"尔格-Emurgo联手为预言机创造了新的模式"},{"contents":"卡尔达诺和尔格在金融去中心化和区块链开发方面采取截然不容的方法，但是在某些特定领域二者存在重大重叠。这为富有成效的合作提供了可能性，这对两个截然不同的生态系统 – 以及整个区块链行业都有好处。\n近期宣布的Emurgo与尔格之间的合作在这两个社区均获得积极评价。理由很充分：这是一个将资源集中投入到一个重要和新兴研究领域的千载难逢的机遇，同时使两个项目得以以其自己的方式和自己的路线图利用所获得的见解。\n在某些方面，卡尔达尔和尔格非常不同。例如，卡尔达诺是一个以Haskell编程语言开发的权益证明平台，并且拥有以自定义基于Haskell的Plutus语言书写的智能合约。\n与此同时，尔格是一种基于Scorex 框架建立的工作量证明平台，该平台也是由尔格的首席开发者Chepurnoy (@kushti)所开发。其智能合约用尔格脚本撰写，其从Scala编程语言汲取特点。\nUTXO智能合约 如果二者存在重叠，并且最具希望的合作领域是双方采用扩大后的UTXO模型。（如希望了解更多信息，请参阅此处尔格采用UTXOs.)\n将智能合约建立在扩大后的UTXO模型是一个比较新的想法。诸如以太坊平台这样的平台采用了账户模型，其有着非常不同的含义。Robert Kornacki（Emurgo的研发工程师） 最近所做的研究做了更详细解释：\n 扩大后的UTXO系统支持经过充分训练的图灵机得以完成（跨交易）智能契约。这是一种新型创新，其令最新一代区块链可以重新收回比特币所采用的原始模型，但其现在的能力要比之前大很多。\n鉴于智能合约驱动的UTXO系统尚处于初级阶段，在建立dApps的时候明显缺乏开发者可以依赖的已知设计模式。看看诸如以太坊这样在UTXO模型中对协议进行编码加密基于帐户的模型，其与功能性的编写命令式代码比较不同。\nUTXO的方法具有对智能合约进行革命性变革的能力，并且由于卡尔达尔和尔格采用了不同的路线图和技术，导致协作的发现将证明其对二者来说无疑是非常有价值的。\n 金融去中心化协作 金融去中心化如何在合作，而非竞争中迅速发展是一个很好的例子。开源系统令彼此受益，使彼此更加强大，利用彼此的网络，而非相互拆台。\n这方面一个很好的例子是Yoroi钱包，为了与基于尔格的dApps以及卡尔达诺的生态系统建立联系，其将成为一种MetaMask钱包。与此同时，尔格已经实施的功能（诸如 NiPoPoW）并且还将在未来继续使用，这对于卡尔达诺和区块链来说是一个先例，即便这些功能无法直接被导入。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020-09-07-%E5%B0%94%E6%A0%BC-emurgo%E8%81%94%E6%89%8B%E7%9A%84%E6%9C%BA%E9%81%87/","subtitle":null,"title":"尔格/Emurgo联手的机遇"},{"contents":"卡尔达诺协议的创始成员EMURGO与尔格合作，并且建立基于区块链的去中心化金融解决方案 新加坡，2020年6月9日/ 全球区块链解决方案公司以及全球公认卡尔达诺协议创始实体EMURGO Ptd. Ltd. – EMURGO, 今日宣布将与尔格建立战略合作 – 将工作量证明区块链协议打造成为一个应用平台，该平台主要专注于为金融合约及其基于UTXO的智能合约提供简单的解决方案。该项目由前IOHK工程师设计与牵头，尔格非常重视为使用网络、长期区块链网络可持续性和去中心化方案的用户提供定制化的隐私。\n该合作协议的范围涵盖利用各自在卡尔达诺技术结构与隐私方面的专业知识以及基于UTXO的智能合约，来联合进行稳定币研发探索以及提供去中心化金融服务应用。\n其还涵盖将尔格的原生区块链代币（尔格币）完全整合进Yoroi 钱包并提供支持 – 该钱包是一种由EMURGO为台式机和手机开发的安全、莱特加密货币钱包，其将处理各种去中心化应用请求，并且可以使卡尔达诺和ADA上发行的代币类型之间进行自由转账。尔格币将是继卡尔达诺的ADA 之后首个被整合进Yoroi钱包的加密货币。\n继为满足企业需求而在近期推出EMURGO可追踪性解决方案之后，EMURGO与尔格建立的战略合作关系与目标进行了统一，还将满足未来有关定制去中心化金融(DeFi)解决方案不断增长的需求。 随着人们对建设去中心化金融服务以及整体区块链行业兴趣的增长，此项合作使开展更为亟需、且更有深度的研究及去中心化金融解决方案成为可能。这些解决方案将探索使用内嵌有隐私功能的尔格智能合约，并且其与卡尔达诺庞大的全球网络可以互操作。这反过来也将赋予开发者、投资者以及利益攸关方使用尔格功能或完全进入更大区块链生态系统（如卡尔达诺）的灵活性。\n目前，约有10亿美元的总价值被锁定在DeFi解决方案中，随着开发的逐渐成熟，这些解决方案将拥有巨大的市场规模。DeFi解决方案的使用案例涵盖传统金融服务，如借贷、实物资产的数字标记以及支付等。 这些解决方案利用区块链技术在满足程序化条款与去中心化的时候，提供自执行金融智能合约，并且没有实体控制的奇点。DeFi为更广泛的人群打开了获取金融服务的大门，提供了包容性和经济赋能，以及各类相互可操作的去中心化解决方案。\n“这是一个为EMURGO汇集了我们各自部门自身实力的天然战略合作，以继续开发符合要求定制隐私保护功能的创新解决方案，这也符合不断增长的去中心化金融服务需求。我们同时还为即将开始向更广泛社区扩大Yoroi钱包的服务感到兴奋不已，”EMURGO首席执行官Ken Kodama如是说。\n“与卡尔达诺创始实体之一以及著名且备受尊敬的机构EMURGO合作，对于探索我们两个协议与有着相似气质，同时具有截然不同和互补技术的团队之间协作所提供的可能性来说是个千载难逢的机遇。卡尔达诺可以说是现有学术上最为严谨的区块链协议，并且EMURGO对于尔格而言是一个非常有价值的技术合作伙伴 – 其总是优先考虑类似以研究为驱动的开发方法。与此同时，与EMURGO的旗舰Yoroi钱包进行整合将使尔格优先于加密领域任一最大的用户基础。特别是，我们对新的稳定币协议的联合研究以及DeFi服务承诺将为双方及其社区以及商业用户提供千载难逢的新开发领域与商业机遇，”尔格团队核心开发团队成员Alexander Chepurnoy表示。\n关于EMURGO EMURGO 是一家全球区块链科技公司，其专注于为开发人员、创业公司、企业以及政府组织提供解决方案。EMURGO开发企业级应用，设计开发工具、投资创业企业并且提供区块链相关教育培训。\nEMURGO在新加坡、日本、美国、印度和印尼设有办事处并负责项目管理。EMURGO是卡尔达诺 协议的创始成员。如需联系了解更多信息，请访问：https://emurgo.io/ .\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020_06_09_ergo_and_emurgo/","subtitle":null,"title":"卡尔达诺协议的创始成员EMURGO与尔格合作"},{"contents":"","link":"https://ergoplatform.org/cn/blog/2020_06_09_ergo_and_emurgo/","permalink":"https://ergoplatform.org/cn/news/2020_06_09/","subtitle":null,"title":"卡尔达诺协议的创始成员EMURGO与尔格合作"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.1","permalink":"https://ergoplatform.org/cn/news/2020_02_19/","subtitle":"内存池和矿工对链下交易的交易输出交易友好，在标题链下载期间用于同步检测的参数等等","title":"“ 发布尔格主网3.2.1版本 ”"},{"contents":"","link":"https://discordapp.com/invite/gYrVrjS","permalink":"https://ergoplatform.org/cn/news/2020_01_23/","subtitle":"欢迎加入我们","title":"尔格平台Discord 平台已经推出了"},{"contents":"我们想宣布尔格已经成功通过某些(最关键的)部分的安全审查。此次审查由 Jean- Philipee Aumasson 负责完成(也叫 veorq, https://aumasson.jp/ )。\n具体报告如下。没有发现任何重大问题。对所发现问题的评论如下:\n  关于钱包密码，我们将在下一版协议节点中提供建议。不确定密码法的执法力度会 到何种程度，但我们会对此做更多的咨询。\n  只有在启动新网络时修改”n”和”k”参数才有意义。修改挖掘节点中的这些参数将使 所生成的区块对其他节点来说无效。修改协议节点的该项参数意味着出现另一个分 叉(来自诚实协议参与者的区块将被拒绝)。所以可能不需要进行额外核验，因为 那些启动新网络的人会正确设置”n”和”k”的参数。\n  目前尔格节点(以及我们所知道的其他区块链协议节点和钱包，以及我们正在使用 的加密库)无法提供防止本地运行的侧通道攻击的保护(如恶意软件或病毒所发起 的时序攻击或内存检查)。所以，请保护好运行你钱包的设备!\n  ============================================================================== =============================\n% 尔格安全性评估% Jean-Philippe Aumasson % 2019 年 12 月日\n摘要 尔格团队邀请我们对其尔格平台的几个组件进行安全性评估\n 创建与验证西格玛协议证明 钱包对秘密的安全存储 工作量证明验证  这份简报介绍了我们的评估，并说明了我们所发现的问题以及应对措施建议。\n西格玛协议证明 尔格协议依赖于尔格脚本，其是一种支持西格玛语句的脚本语言，可以通过非交互式的 知识证明来进行证明以及验证。\n这些证明是一个类似于树的语句和/或阈值条件，其树叶是离散对数问题的知识证明。\n西格玛语句证明是非交互式的，这应归功于 Fiat-Shamir 的转换\n该逻辑在尔格脚本报告中有详细说明，并且详细的证明与验证流程在其附录 A 中有介 绍。\n实施过程中的挑战包括:\n  定义安全高效证明的编码，并且实现总是成功处理有效输入的序列化，以及总是无法处 理无效输入的反序列化。\n  根据规范正确地实现证明与验证功能，最重要的是确保没有无效语句能够成功通过验 证。\n  我们对这两个方面进行了回顾，根据存储库 sigmastate-interpreter中的代码和尔格脚本报 告，对(附录 A 中的)预期行为与实际所采取的行为进行仔细比较。\n我们会重点审议来自 SigSerializer、Interpreter 的代码以及 ProverInterpreter 特征和目标。\n我们主要寻找来自以下类别中的故障:\n 缺陷输入的不安全处理 不安全处理超长或超短的输入 大树深度或递归级时的行为 不安全使用 Scala 类型和结构 不合适的变量类型 整数溢出 竞态条件 逻辑缺陷  尽管进行了详尽审查，但是我们没未发现任何安全问题。\n协议的逻辑和内部机制是比较复杂的，我们认为最大的风险在于对证明进行分析与验 证。然而，为了利用这些漏洞，攻击者必须创建一个在某种程度上会令自己受益的语义 正确脚本，并且在不应通过验证的时候通过了验证。\n在软件安全方面，Scala 消除某些类别的缺陷，但是由于 Scala 的特定行为或未处理的错 误，Scala 代码可能依然会受到缺陷的困扰。\n钱包 因此，尔格钱包功使其用户能够用磁盘存储与恢复秘密，并且在初次使用的时候，可以 用一个新的种子对钱包进行初始化操作。\n该逻辑主要在 ErgoWalletActor 中进行定义，有关秘密存储的一个主要构件是 JsonSecretStorage。\n首次创建钱包时，InitWallet 命令执行以下操作\n 生成作为初始熵的 settings.walletSettings.seedStrengthBits 随机位。在默认情况下 ，生成 160 位。 从生成的随机位中生成一个 BIP39，其可以被视作一个熵位的编码。采用密码可选的标准 BIP39 逻辑。 使用 BIP39 基于 PBKDF2 的推导逻辑，从助记符中推导出种子。 采用一个随机数，通过 AES-GCM 将该种子加密到磁盘，使用拥有 128000 次迭代的 PBKDF2-HMAC-SHA256，并利用一个随机盐从密码中产生出一个密钥。  要像解锁一个已经创建的钱包，用户提供密码，钱包将尝试解密所存储的数据。\n为了从 BIP39 口令恢复现有帐户，需要执行一个类似于初始化的流程，只不过钱包将从 助记符中，而非从随机助记符中获得种子。\n我们在此确定的两种风险包括:\n  缺少对密码长度的检查:由于钱包实在磁盘上存储秘密，既然密码足以访问种子，从理 论来讲，密码的熵至少应当与助记符相同，而在实际上应该很难破解。因此，我们建议 采用最小的密码长度，如 16 个字符。\n  在钱包软件执行后，秘密值(密码、种子和派生私钥)的副本可能会留在内存中，其是 诸如 Scala 等垃圾收集语言的内在局限性。\n  共享相同内存地址空间的另一进程或用户可能会恢复这些秘密，并且他们也可能出现在 崩溃转储中。据我们所知，在纯 Scala 中没有有效的缓解。 ​\n工作量证明的验证 在先前检查奥托吕克斯共识协议工作量证明安全性之后，我们进行了另一轮检查，重点 关注其最新的验证逻辑，特别是在承诺 eb0f85a 中所做的更改。\n主要的相关文件是 AutolykosPowScheme，其他重要操作在诸如 HeadersProcessor 和 ModifierValidator 中实施。\n我们检查所实施的验证逻辑与奥托吕克斯共识协议规范中所规定的验证逻辑是否一致， 并且其已被妥善整合进区块头的验证逻辑。\n我们认为应解决以下问题:\n  对k 和 n 进行更严格的验证:虽然类强制执行 k\u0026lt;=32 (解决方案中的元素数量)和 n\u0026lt;31 (元素总数的 log2 值)，但依然可以从授权的参数中创建弱区块。因此，validate()函数可 能需要进行额外的验证，确认 n 和 k 是否等于预期的值。\n  断言 k 和 n 为正值，因为当前的负值(称作 Ints)将传递 assert 语句。\n  ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2020_01_12_security_audit/","subtitle":null,"title":"(Jean Philippe Aumasson 所进行的)安全审查"},{"contents":"","link":"https://ergoplatform.org/en/blog/2020_01_12_security_audit/","permalink":"https://ergoplatform.org/cn/news/2020_01_12/","subtitle":"尔格已成功通过了代码最关键部分的安全审核","title":"安全审核 (审核员 Philippe Aumasson)"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.2.0","permalink":"https://ergoplatform.org/cn/news/2020_01_07/","subtitle":"此版本包括重大更改和改进。需要重新同步，版本说明中有更多详细信息","title":"发布尔格主网3.2.0版本"},{"contents":"尽管当今此领域最活跃话题是如何普及区块链技术（这通常意味着出售给华尔街）以及如何与维萨卡和万事达卡等系统进行竞争（这通常意味着利用去中心化而放弃，或以效率的名义引入不明确的安全假设），显然有必要对加密货币变化的原因进行重新审视，这些变化大多与去中心化有关。我接下来将在此给出许多问题的明确答案。将90%的比特币开采能力都集中在一个房间里? 是否可行？两三个矿池控制大部分算力是否可能？审查也可行吗？让几乎全部新节点避免处理来自其创世区块的区块链是否可行？工作量证明货币开发者正在做一个旨在改变一致性算法的硬叉，使其再次变得对图形处理器(GPU)友好是否可行？我们能否总结一下与去中心化相关的全部问题？我们能否用技术手段解决大部分问题？\n去中心化涵盖技术、社会及跨界等众多领域的多个问题。研究人员和开发人员正在努力寻找技术解决方案，首选完美且高效的解决方案。然而，对于许多问题而言，依然没有找到解决方案，因此就需要社会解决方案。\n在这篇文章中，我将只讨论去中心化的技术方面，即采矿的去中心化和验证的去中心化。\n采矿的去中心化 关于采矿去中心化的两个最大的问题是专用硬件（如专用集成电路(ASICs)）和中心化池。\n凭借专用集成电路，一个拥有足够资金投资研发的大玩家可以从私人拥有的高效硬件中获得不公平优势。原则上来讲，对于任何类型的计算活动，开发性能优于商用计算设备（如CPUs 和GPUs）的专用硬件永远都是可能的。然而，对于不同的计算任务而言，研发努力与可能的结果却可能大相径庭。搜索一个完美（或者近似完美结果）背后的推理可能相当复杂（参见30多页厚的Equihash报告).\n对于大部分工作量证明加密货币而言（包括比特币、以太坊、ZCash），2-4个中心化挖矿池控制着大部分开采力。这可能意味着审查变得容易或者进行提前交易（例如，对交易所订单进行重新排序），因为在中心化池中，只有中心化池自己才有权决定其所负责的整个池中的候选区块。作为一种可能的结果，不可外包的采矿方案可以防止中心化池的出现。只有尔格平台因部署了一个名为奥托吕克斯共识协议(Autolykos)的实用性不可外包工作量证明方案（基于Equihash报告中据说是更难记忆的问题）而闻名。\n作为社会去中心化问题符合采矿去中心化的一个例子，有时工作量证明的开发者正在引入硬叉，以便一旦ASICs在未来主宰了挖矿市场，则工作量证明算法会对图形处理器再次变得友好。然而，尚不清楚为什么完全合法的活动总是被禁止，为什么开发人员（以及部分用户）可以出于特殊原因而做硬叉。\n验证的去中心化 验证的去中心化是关于核实区块链历史有效性的可能性。这种核实使人确信没有不好的东西（即：不符合协议）被注入到区块链中，从而给予用户拒绝恶意区块链的权利，即使其比其他方法吸收了更多的工作量。当用户激活软叉（UASF）的想法开始走红时，社会上有很多有关比特币社区此项权力的讨论。很好地总结了这种思维方式。最近一篇题为“谁为比特币担保”的文章很好的总结了这种思维模式。\n如果一个实体能够在合理的时间范围内通过花费数百万美元租用数据中心来进行验证，那么这个网络显然不是去中心化的。理想情况下，应该可以在商用硬件（如一台像样的笔记本电脑）上检查整个区块链的完整性。\n然而，新的区块链也倾向于吸收越来越多的功能，而且这些功能并非免费的。然后，研究社区的主题是关于如何在合理的假设下，通过修剪区块或系统状态（或两者）来检查整个区块链的完整性。这里可能的解决方案有：引导状态速览及基于此的区块链后缀（在以太坊协议节点中比较流行，甚至在一篇学术论文)中正式提出）、无状态节点（在尔格平台上实现 部分无状态，或者目前只存在于研究论文中的完全无状态）。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_12_12_new_quest/","subtitle":null,"title":"去中心化方面的新探索，第一部分：技术方面"},{"contents":"本教程将解释如何安装与运行全尔格节点。其不涉及采矿相关的内容。\n节点安全 节点的使用涉及几个重要方面的内容，你的钱包和钱的安全性取决于以下方面:\n 尔格节点需要在配置文件中存储安全关键参数。你永远不应把这个文件公开。 尔格节点提供用于与内置钱包互动的REST API。敏感的API方法需要一个安全令牌，你永远不要通过不可靠的渠道发送该令牌。 访问尔格REST API必须限制在认识的主机上。尤其是绝不允许通过互联网访问API。  先决条件 为了运行尔格节点，你需要JRE版本\u0026gt;= 将要安装的8。其中一种安装方式是使用 甲骨文安装Java.\n接下来需要下载最新的尔格客户端发行版 jar文件，并且创建一个节点配置文件。\n注意：你不用下载jar，你可以克隆资源库，然后通过发布sbt assembly指令，自己利用SBT 来创建jar。\nergo_folder是指存放jar的文件夹。\n首席运行节点 创建在ergo_folder中含有以下文本的配置文件ergo.conf。\nergo { directory = ${ergo.directory}\u0026#34;/.ergo\u0026#34; node { mining = false } wallet.secretStorage.secretDir = ${ergo.directory}\u0026#34;/wallet/keystore\u0026#34; } 参数${ergo.directory}指向jar运行的目录。向ergo_folder开启命令提示符和cd。然后发出以下命令来首次运行节点：\njava -jar ergo-\u0026lt;release\u0026gt;.jar --mainnet -c ergo.conf 之后节点将立即开始同步。API启动与进入到下一步需要等几分钟。\n注意：对于文件你可以使用任何名称，而非ergo.conf。全部配置参数将被传送给该文件，你只需要重写你想修改缺省值的参数。上述配置文件实际上有缺省值。\n计算你秘密的哈希值 首先，选择一个秘密来保护你的API。然后前往 http://127.0.0.1:9053/swagger#/utils/hashBlake2b 然后调用API来计算你秘密的哈希值。参考下图。\n复制含有哈希值的回复以便下一步使用（参见下图）。在我们的例子中，秘密是是 hello 谁的哈希值对应324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf.\n重要提示：你必须使用不同且比较复杂的秘密.\n利用API关键哈希值来更新配置文件 编辑配置文件ergo.conf然后粘贴前步所复制的哈希值。文件内容应当看似如下：\nergo { directory = ${ergo.directory}\u0026#34;/.ergo\u0026#34; node { mining = false } wallet.secretStorage.secretDir = ${ergo.directory}\u0026#34;/wallet/keystore\u0026#34; } scorex { restApi { # Hex-encoded Blake2b256 hash of an API key. # Should be 64-chars long Base16 string. # below is the hash of the string \u0026#39;hello\u0026#39; # replace with your actual hash apiKeyHash = \u0026#34;324dcf027dd4a30a932c441f365a25e86b173defa4b8e58948253471b81b72cf\u0026#34; } } 初始化钱包 重启节点并且前往http://127.0.0.1:9053/panel 以访问面板。然后设置上一步的API主要秘密。注意你需要设置秘密，而非配置文件的哈希值。在我们的举例中，这是字符串hello.\n最后，点击“初始化钱包”：\n在弹开窗口中，您必须输入钱包密码。助记符密码是或选项。点击发送后，钱包会返回一个助记句，如下图所示。\n你必须把这个句子抄下来，并把它保存在一个安全的地方。如果你要在其他计算机恢复你的钱包，就需要这个句子。\n获得钱包的地址 这是一个可以确保你正确设置节点的测试。它将返回钱包中的当前地址。 在http://127.0.0.1:9053/panel 的面板上，点击左侧的Wallet 条，然后点击 Get all wallet addresses 以浏览钱包目前所保存的地址。如果节点设置正确，那么至少应该返回一个地址。\n使用Swagger UI 你可以在http://127.0.0.1:9053/swagger找到Swagger UI。你还可以使用该UI对面板上（尚不）能用的高级操作进行API调用。你之前已经用其来计算你秘密的哈希值。你还可以使用这个UI来为面板中（尚未）提供的高级操作进行API调用。部分举例如下：\n 利用寄存器和上下文变量来创建非标准交易。 创建发出令牌的交易。 创建使用某些框作为输入值的交易。  未来的文章将逐一详细介绍这些操作。\n请注意API中的大部分方法都受到保护，你需要使用你（之前）的秘密来获得这些方法。接下来的图片将展示在Swagger UI中设置该秘密的流程。\n在页面顶端，点击“授权”键。在弹出框中输入您的秘密，如下图所示。\n输入密码后，点击“授权”，将跳出以下界面：\n现在转到http://127.0.0.1:9053/swagger#/wallet/walletAddresses ，然后点击“试一试”。你会看到你之前从面板上看到过的相同的地址列表。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_12_02_how_to_setup/","subtitle":null,"title":"如何设置与配置全尔格节点"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.2","permalink":"https://ergoplatform.org/cn/news/2019_10_14/","subtitle":"“此版本包括重新广播内存池交易。禁用了生成P2SH地址的API路由”","title":"发布尔格主网3.1.2版本"},{"contents":"","link":"https://help.hotbit.io/hc/zh-cn/articles/360036438614-Hotbit%E5%AE%9A%E4%BA%8E10%E6%9C%889%E6%97%A5%E4%B8%8A%E7%BA%BFERGO-ERG-","permalink":"https://ergoplatform.org/cn/news/2019_10_08_2/","subtitle":"10月9日15:00（北京时间）开放ERG充值，同时开放ERG/BTC交易对","title":"Hotbit交易所上线ERGO (ERG)"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.1.1","permalink":"https://ergoplatform.org/cn/news/2019_10_08/","subtitle":"新UI（127.0.0.1/panel）。以后会在新版本推出简单化钱包。新API方法能从脚本取得钱包状况和地址。","title":"发布尔格主网3.1.1版本"},{"contents":"","link":"https://github.com/bisq-network/bisq/releases/tag/v1.1.6","permalink":"https://ergoplatform.org/cn/news/2019_09_16/","subtitle":"BISQ, 是去中性化的P2P交易网络, 已经增加了尔格币（ERG）","title":"BISQ 已经正式了加了尔格币(ERG)"},{"contents":"","link":"https://p2pb2b.io/trade/ERG_BTC","permalink":"https://ergoplatform.org/cn/news/2019_09_14/","subtitle":"我们很荣幸地宣布尔格币($ERG) 已经在P2PB2B交易所挂牌交易","title":"尔格币($ERG) 已经在P2PB2B交易所挂牌交易"},{"contents":"什么是众筹？ 众筹是一种通过许多人的努力实现一种融资方式。众筹多通过全球网站启动，使项目和企业可以通过众多个人的小额出资来完成融资。通过众筹方式成功创业的最经典案例之一就是虚拟现实耳麦 - Oculus Rift。Oculus VR公司在2012年发起众筹，仅在两年后就被脸书以20亿美元的价格所收购。除了常规创业企业以外，还有许多区块链项目也选择采取众筹模式，例如：乙太坊、Tron和EOS。目前市场上有无数众筹平台。部分较大的众筹平台包括Indiegogo、Kickstarter和Gofundme，不一而足。众筹方式有很多好处：覆盖面广、高效以及最具说服力的营销… 但是现在，让我们看一下其最核心的一点！\n为尔格引入众筹模式 就在几天前的8月28日，核心开发者 Kushti 在（尔格论坛上）[www.ergoforum.org]表示他成功写出并且实施可以让用户在尔格区块链开展众筹活动的代码（如白皮书第6页. 所述。该代码甚至与当前的钱包API相结合。这里是如何建立钱包的快速指南。在这篇文章中，你将学习如何具体开展尔格众筹工作！还将带你看一下有史以来首次众筹建议书，其将为EIP1后众筹文本撰写工作提供资金支持。如果你想了解更多细节，请阅读以下“脚本”章节。此外，你也可以跳过这一章，直接阅读后面“如何捐款”、“如何收集捐款”以及“众筹项目建议书”等章节。\n脚本 根据尔格脚本白皮书（第6页）, 最简单的众筹脚本是“有关下列众筹情况的脚本：（持有主要出资人公钥的）项目出资人希望为（拥有要出资人公钥的）项目捐款，但前提是该项目在最后期限前从其他渠道筹集到足够的资金（至少达到融资下限）（以高度表示）。为了给项目捐款，出资人将创建一个受以下脚本保护的输出框。该脚本有两个条件：一种情况是最后期限已过，融资失败（出资人可以将钱要回来），另一种情况是成功实现融资（如果融资金额在最后期限前达到了所规定的最低融资门槛，那么项目就可以用这些钱）。\n为了确保融到足够多的资金，脚本将在全部输出结果中搜索一个框，并且向项目公钥分配足够多的值。为了检查输出框值的去向，脚本将读取保护输出框的脚本，并且将其与proveDlog对应的脚本进行比较（项目公钥）；该脚本可以通过projectPubKey.propBytes获得。\n由于目前API不支持嵌入自定义环境变量（只有诸如高度等预定义变量），因此编译脚本的唯一方法是用具体值替换白皮书中的这些变量。例如，想想看，如果一个众筹活动在第5万个区块前筹到500个尔格币，那么这次众筹就是成功的。 对于出资人公钥（backerPubKey）和项目公钥而言，我们可以采用目前只接受P2PK序列化钥匙的PK()函数。 如此，白皮书修订后的脚本如下：\n{ val backerPubKey = PK(\u0026#34;9h7DHKSDgE4uvP8313GVGdsEg3AvdAWSSTG7XZsLwBfeth4aePG\u0026#34;) val projectPubKey = PK(\u0026#34;9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\u0026#34;) val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT \u0026gt;= deadline \u0026amp;\u0026amp; backerPubKey val enoughRaised = {(outBox: Box) =\u0026gt;outBox.value \u0026gt;= minToRaise \u0026amp;\u0026amp; outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT \u0026lt; deadline \u0026amp;\u0026amp; projectPubKey \u0026amp;\u0026amp; OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess } 如何捐款 首先，JSON不支持多行字符串，因此需要用\\n替换换行符。此外，引号将被转意，因此使用“而非”。生成的JSON将被发送到/script/p2sAddress。为了给项目捐款，首先要从/钱包/众多地址中获得你的地址，比如说，提取它们中的第一个。把地址输入出资人公钥，这样在这一步之后对/脚本/p2sAddress的请求看起来以下情况：\n{ \u0026#34;source\u0026#34;: \u0026#34;{ val backerPubKey = PK(\\\u0026#34;9...\\\u0026#34;) val projectPubKey = PK(\\\u0026#34;9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\\\u0026#34;) val deadline = 50000 val minToRaise = 500L * 1000000000 val fundraisingFailure = HEIGHT \u0026gt;= deadline \u0026amp;\u0026amp; backerPubKey val enoughRaised = { (outBox: Box) =\u0026gt; outBox.value \u0026gt;= minToRaise \u0026amp;\u0026amp; outBox.propositionBytes == projectPubKey.propBytes } val fundraisingSuccess = HEIGHT \u0026lt; deadline \u0026amp;\u0026amp; projectPubKey \u0026amp;\u0026amp; OUTPUTS.exists(enoughRaised) fundraisingFailure || fundraisingSuccess }\u0026#34; } 以及你的地址，而非“9…”.\n将字符串发送至 /script/p2sAddress以获得诸如以下反馈：\n{ \u0026#34;address\u0026#34;: \u0026#34;GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\u0026#34; } 复制地址字符串（GB3… 在我们的例子中），并且将钱通过/wallet/payment/send 汇入该地址。提出采用API方法发送10个尔格币（100亿个毫微尔格(nanoErgs)）的请求如下所示：\n[ { \u0026#34;address\u0026#34;: \u0026#34;GB3kh2izpWKvyZfMboQwsEscjPaZcz9WrzGqZB4ZrkzRreiFMV6HZYWXGMK3rqCjDCoPgWGNzfnYSUhivW4a1VRYPE7uZXwKnBcqWcRkiuTx6QW55EcPcWeELUsumwdtKoFtWY583nWnKZff\u0026#34;, \u0026#34;value\u0026#34;: 10000000000 } ] 大功告成！\n现在钱包将可以自动找到区块链的币箱，因为其在退款条件下含有属于钱包的公钥。由于（对相同地址）一个输入值只产生一个输出值，因此钱包会定期通过与币箱进行最简单的交易以检查币箱是否有钱。 在退款高度（我们的例子中是50,000），钱包将花币箱里的钱，因此币箱价值将在加入/钱包/余额。请注意在采用EIP-1 3后，情况会有所不同，因为到那时候钱包将采用窄识别模式。\n如何收集捐款 与项目公钥挂钩的钱包将发现区块链上新到的币箱。然而，其将无法确保币箱是有钱的，因为钱包目前采用的是最简单的交易，对于此类支出交易，脚本是无法做到的。在 /wallet/boxes/uncertain 方法采用之前，这是项目发现新到币箱的唯一方法。那时候 /wallet/transaction/send 和手工提供的（在“inputsRaw”）序列化币箱（采用 /utxo/byIdBinary 通过标识符获得序列化币箱）。\n那时候Kushti自己完成，并且获得以下 交易.\n请注意EIP-1 也将打破这一工作流程。\nKushti 提议在区块50,000之前筹集500个尔格币，以（用Python语言）撰写命令行脚本，为EIP-1实施后组织与参与众筹活动作准备。命令行脚本比手工处理请求更为适合，亦可用来在其上面构建图形界面。\n司库的确提供一半的资金，因此其他人需要一起贡献另外250个尔格币。如果众筹活动失败，资金将被自动退回。由于目前筹款并非易事，Kushti将牵头这一工作，因此请使用以下由他所控制的密钥：\n9gBSqNT9LH9WjvWbyqEvFirMbYp4nfGHnoWdceKGu45AKiya3Fq\n为了捐赠任何数额的款项，请阅读上面“如何捐款” 章节，用你的公钥取代出资人公钥，并且赋予金额适当的价值（请注意其以毫微尔格计值，1尔格= 1.000.000.000 毫微尔格）。 如果阁下有任何问题、建议或者希望参与我们的活动，欢迎随时加入我们的社交媒体群或论坛。\n如果阁下有任何问题、建议或者希望参与我们的活动，欢迎随时加入我们的社交媒体群或论坛。\nt.me/ergoplatform | t.me/ergo_mining | www.ergoforum.org\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_09_06_crowdfund/","subtitle":null,"title":"尔格和众筹"},{"contents":"","link":"https://twitter.com/Hotbit_news/status/1169883351093694464","permalink":"https://ergoplatform.org/cn/news/2019_09_06/","subtitle":"我们很荣幸地宣布尔格币($ERG) 将在Hotbit交易所挂牌交易","title":"尔格币($ERG) 将在Hotbit交易所挂牌交易"},{"contents":"","link":"https://x.vite.net/trade?symbol=ERG-000_BTC-000\u0026category=BTC","permalink":"https://ergoplatform.org/cn/news/2019_08_20/","subtitle":"我们很荣幸地宣布尔格币($ERG) 已经在Vgate交易所挂牌交易","title":"尔格币($ERG) 已经在Vgate交易所挂牌交易"},{"contents":"本教程将向你提供在Windows或Linux环境下利用AMD卡开采尔格币的所需信息.\n开发者MH Samadani 在正式推出后第3天就发表其AMD矿工，并且之后还在不断对其进行更新。为了跟踪其最新动态，你可以加入尔格采矿电报群并且搜索 #amdminer。你可以在此查看矿机。\n编码是基于OpenCL并且是完全开放源代码。如果你用的是Nvidia 卡，你可以在此找到CUDA矿机。\n请注意，使用任何封闭源代码矿机是不安全的。尔格的开采特点要求你必须将你的密钥提供给矿机，以在任何脆弱数据面临危险之前确定谁值得信任！\n以下是AMD卡的报告哈希率：\n rx570-8g: 22-24Mh/s rx580-8g: 23-25Mh/s rx Vega56: 24-26Mh/s  在进一步说明之前，我想对MH Samadani和主要开发人员Amin Moradi为矿工和同仁编写此教程的付出表示感谢！\n现在让我们开始吧！\n配置 将这些文件复制到相同的文件夹作为你的可执行文件，并且将你的种子字符串和节点地址添加到 config.json。除了在相同文件中设置keepPrehash: true 之外。\n Miningkernel.cl Prehashkernel.cl Ocldecs.h Ocldefs.h Libcurl.dll(在windows环境下) Config.json  对Linux的要求 1. 通过下载你来自amd.com特定Linux 发行版的AMDGPU-PRO 软件包来安装AMDGPU-PRO驱动器。打开该文件包，并且在终端窗口运行： $ amdgpu-pro-install --opencl=legacy,pal --headless 2. 安装OpenCL 头文件 $ apt install libcurl4-openssl-dev 3. 安装OpenSSL 1.02 $ apt install libssl-dev 对Windows的要求 1. 你需要至少一个AMD GPU，其驱动器安装了 amd.com 2. 从此处的 mhssadini’s github 下载与安装AMD APK 3. 如果没有现成的，利用含有可视化工作室工具链说明的源代码建造网络库libcurl 4. 从此处下载与安装OpenSSL 1.0.2 在Linux环境下建造 1. 在主目录下编辑 ErgoOpenCL.cpp ，并且加批注 #define TEST 或者取消批注 define TEST 以建造矿机或者测试机。 2. 将目录改为 ergoAMDminer/Ubuntu ，并且运行make. ./makefile 3. 如果每一步都运行无误，你应当可以在ergoAMDminer/Ubuntu/下找到ErgoOpenCL。继续，运行程序，开始开采。 ./ErgoOpenCL 针对Windows的预制版本 下载github，前往win64文件夹，然后执行 ErgoOpenCL_miner.exe 或 ErgoOpenCL_tester.exe。如果每一步都运行无误（参见要求与配置），其应当可以开始开采。\n在Windows环境下建造 打开 ErgoOpenCL.sln 可视化工作室。增加OpenCL、LibCurl和OpenSSL库。 包括目录：\n并且包括其他目录：\n其他库目录：\n其他依赖性：\n在ErgoOpenCL.cpp 文件中，加批注 #define TEST 以建造矿机，或取消批注define TEST 以建造测试机。\n如果你还有其他问题、建议，希望送花给 @mhs_sam 或者就是想加入社区，快加入我们的电报群 - 尔格采矿 或尔格平台 – 来打声招呼吧！\n祝挖矿顺利！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_08_07_amd/","subtitle":null,"title":"利用AMD卡开采尔格币"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.6","permalink":"https://ergoplatform.org/cn/news/2019_08_06/","subtitle":"此次发布为矿工引进了一个针对累计交易输入脚本复杂性的过滤器。对钱包、API方法和Swagger UI进行了更新","title":"发布尔格主网3.0.6版本"},{"contents":"在今天的文章中，我们的将对尔格地址的格式化一窥究竟。除此之外，我们将说明他们具体的具体工作原理，以及什么使其优于其他类型的区块链地址。\n让我们从头说起。\n在你安装任何数字货币钱包的时候，你会自动创建一个地址。简单来说，这个钱包就好比一个传统银行账户，而地址就如同与之相匹配的账号。如果你需要把钱由甲打给乙、收款或者提走你的挖矿奖励，那么你就需要一个字母数字地址提取你的挖矿奖励。\n如果你希望利用尔格钱包启动，并且想深入了解其功能，请双击以下链接.\n那么，到底什么是地址呢？\n地址是与某些脚本相对应的短字符串，并且用于保护一个币箱 （在此贴中，核心开发者kushti 在我们的论坛中发表文章详细解释了什么是币箱(“box”)。\n与（十六进制编码）二进制脚本描述有所不同，尔格地址采用Base58编码，因此拥有一些二进制描述无法提供的非常有用的特性：\n 地址的完整性可以轻易通过一体化校验和进行检查（根据维基百科的解释，其是“出于探测那些在传输与存储期间可能导入错误之目的，从一堆数字资料中得出的小型数据”）。 地址的前缀告诉你网络和地址的类型。尤其是网络前缀可以防止你误将主网代币发到测试网的地址。 地址使用一个编码（即：上面提到的 Base58），其可以避免长得很像的字符 ，并且方便双击以及在电子邮件中进行换行。 地址是编码网络类型、地址类型、校验和以及足以与特定脚本相对应的信息。  让我们看一下含有有关网络和地址类型信息的前缀字节：\n可能的网络类型包括：\n 主网 - 0x00 测试网 - 0x10  地址类型包括（下述语义学）：\n 0x01 - Pay-to-PublicKey(P2PK) address 0x02 - Pay-to-Script-Hash(P2SH) 0x03 - Pay-to-Script(P2S)  对于地址类型，我们建立的内容字节如下：\n P2PK – 序列化（压缩）公钥 P2SH - 序列化脚本字节Blake2b256 哈希的前192个比特 P2S – 序列化脚本（这就是挖矿奖励的去处!）  举例来说，将10个尔格币发到P2PK 地址通常意味着对应的交易将包含一个币箱，在这个币箱中用P2PK地址中编码的公钥锁住10个尔格币。与此相类似， 如果是P2S地址，币箱将被地址中编码脚本锁住。如果是最复杂的P2SH脚本，币箱将获得特别预先确定脚本的保护，其将对脚本采用Blake2b256 哈希值前192个比特，在币箱支出时，应当会通过输入值显示。\n以下是特定地址将如何看待测试网的例子：\n 3 - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN) ? - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB) ? - P2S (Ms7smJwLGbUAjuWQ)  以下是他们对我们主网的看法：\n 9 - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA) ? - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg) ? - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)  归纳如下：\n 前缀字节 = 网络类型 + 地址类型 (举例来说，测试网的P2S脚本由Base58之前的0x13开始) 校验和 = leftmost_4_bytes (blake2b256 (前缀字节 || 内容字节)) 地址 = 前缀字节 || 内容字节 || 校验和  如果阁下对其中任何内容感兴趣，非常欢迎阁下加入我们的社区，并且在我们的电报群和/或论坛中咨询更多问题。期待你的加入！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_07_24_ergo_address/","subtitle":null,"title":"尔格地址"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.4","permalink":"https://ergoplatform.org/cn/news/2019_07_19/","subtitle":"此次发布在候选区块生成算法中引入了一个带有时间标记的缺陷修复。向各位矿工强烈推荐","title":"发布尔格主网3.0.4版本"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.3","permalink":"https://ergoplatform.org/cn/news/2019_07_18/","subtitle":"此次发布包括修补与引入新的API方法。有关此次发布的更多详情，请点击","title":"发布尔格主网3.0.3版本"},{"contents":"","link":"https://magnumwallet.co/?coin=erg","permalink":"https://ergoplatform.org/cn/news/2019_07_11/","subtitle":"我们很荣幸地宣布尔格币($ERG) 已与Magnum钱包相挂钩","title":"尔格币已进入Magnum钱包"},{"contents":"首先，我们感谢各位热心人士、开发者、矿工、社会各界以及我们的家人在尔格开发与启动过程中所给予我们的大力支持与无私帮助。尔格的启动为团队在过去几年的初始研发画上了句号，同时也开启了一个新的时代，核心技术大体定调，继续完善协议落实与基建项目将成为工作重点。\n当前核心-尔格核心团队将全心致力于项目开发（至少，同时Foundation Treasury正在推进这方面的工作）。基于此，请允许我介绍一下当前项目的进展情况以及未来规划。\n项目的当前进展状况 首先，关于尔格，我想提醒各位注意以下几点:\n  其依然是一个相对保守的工作量证明区块链，其对尔格币的供应量会进行严格限制；这是一个类似于比特币的交易模式，在区块间精心挑选目标时滞等。从这种意义上来说，尔格币类似于比特币，并且时间已经证明这是对那些注重去中心化和币值稳定人的最佳选择。\n  尽管其是一种（含有未花费的交易输出的）类似于比特币的交易模式，在不牺牲安全的前提下，尔格币支持强化合约货币可能性。我们已经拥有众筹、首次代币发行、冷钱包合约等几个例子。同时，尔格可以轻松获得基于普通离散对数的零知识证明，因此其对于在此基础上设计的协议来说会更好（在某些情况下，会是唯一的选择）。例如，现在每3个多签名中就有2个在网络上完成，该签名维持零知识（因此没有第三方观察员可以确定哪两方实际签署了交易的输入）。同样，环状签名（每N个签名中就有1个维持零知识）将免费提供。另外请看一下Ergomix, 这是一个(非互动性混合计划)[https://ergoplatform.org/docs/sigmastate_protocols.pdf]，并且可能是首个实用的非互动性混合建议。\n  尔格对于常规代币提供原生支持。其还对可以信赖的认证数据结构提供支持（可信方在区块链以外对数据集进行的修订）或者不可信（根据合约规定在区块链上进行修订，然而只有非常小的数据集摘要被存储在未花费的交易输出（UTXO）集上）。\n  其拥有抗池的(pool-resistant)和（在一定程度上）抗ASIC（ASIC-resistant）奥托吕克斯工作量证明计划，主要针对最高级图形处理器(GPUs)，性能最优的GPUs是8gb+ RAM.\n  随着时间的推移，全节点数量可能会出现下降，为了更好地去中心化。尔格首次支持支持无国籍绝对安全客户。高效的轻钱包（SPV）客户支持也已经完成，但是这是采用(NIPoPoW技术)[https://nipopows.com/]，而非Grin所使用的FlyClient技术。\n  没有必要对修改区块容量以及许多其他参数进行激烈辩论。仅拿区块容量为例，一名矿工只需在一个纪元（其由1,024个区块所构成）开始时进行投票就好，如果纪元内有超过50%的矿工支持修改（区块容量增加或者减少1%），那就会进行修改。对于协议的许多方面来说，如果超过90%的采矿权投票是针对软分叉的，那么软分叉更新就是可能的。（具有软分叉属性的）比特币和（具有动态瓦斯限值的）以太坊可以在一定程度上进行协议参数修改。然而，尔格币可以通过其矿工投票机制来对协议的许多方面进行修改与改进。\n  目前所有这些特征或许还不太明显，因为其才启动一个星期，但是他们将从长期定义尔格币的独有特征。请注意，对于长期成功而言，你需要从第一原理开始，而尔格就是从第一原理开始的，而非仅仅是在技术方面（:请注意尔格在白皮书中第2章所记述明确定义的社会契约。\n推进尔格核心团队的职责 尽管参考节点的实施工作还算大体顺利，然而即便对于熟练用户而言，其界面依然令人感到困惑，现在还没有诸如钱包、用于开发应用程序的框架等基础设施。因此核心团队将在未来几个月花时间创建所需框架，改进应用程序界面（API）以及支持钱包和交易所，其部分工作目前已经上马。另外请注意：目前节点的许多构成要素效率还不高，因此在可预计的将来，节点性能将会大幅提高。与此同时，外部团队将继续开展安全性审查。对协议设计和参考实施最关键部分的审计工作已经完成，其有时候是由几方协作完成的。\n硬分叉政策 尔格正在努力避免硬分叉。发行（Emission）、工作量证明、交易模型基本原理以及其他核心问题绝对不应被修改，因为对设计核心部分的任何修改都意味着创建另一个区块链。但是，开发者可以在前12个月内提出硬分叉，当（且仅当）：\n 硬分叉只是为了修补安全漏洞。唯一例外是通过矿工投票使部分特定指令的成本可调整，其是有计划的，但不是在目前主网上完成的。 硬分叉获得超过90%矿工支持的时候。 硬分叉没有违反旧的合约、冻结或者转移任何资金。  社区很重要！ 开发对于外部贡献者来说应当更透明与开放，尔格的开发应当逐渐转变为采用EPIPs （EPIP是指“尔格平台改进建议”）。任何拟议修改应当首先作为正式文件（EPIPS）提出，在正式实施之前可以对其进行讨论、辩论与修改。这相当于比特币和以太坊所分别采用的BIPs和EIPs。\n尔格还需要一个与此相围绕的框架与应用生态系统。一部分资金将被用来奖励生态系统的开发者。奖励计划的详情将在稍后公布，然而，如果你有任何建议，可以立刻联系尔格核心团队。同时，团队非常欢迎各类建议以及所需的API改进想法等。鉴于团队对协议稳定性的承诺，从投资者的角度来看，相较于其他区块链，投资尔格以外的项目可能更有价值。\n此外，请帮助宣传尔格币这个概念！我们是一个刚刚蹒跚学步处于萌芽阶段的区块链，正在寻找那些有志于参与文件起草、撰稿和其他材料的志同道合者。\n尔格和尔格数据 首先，（几年前）曾宣布将会推出两个区块链 -尔格和尔格数据。它们的技术是相同的（或者非常类似），但是参数有所不同。尔格数据背后的主要思想是服务数据密集型应用需求，如：土地登记、证书名录等。\n目前，尔格数据的计划还不明朗。只有在用户对其产生需求的时候才会启动该网络。此外，尔格数据最可能是尔格的一个侧链。同时其无论如何不会在短期内推出，只有当尔格打下完善的基础设施基础后方可能推出。尔格数据链一旦推出，在尔格币推出时，尔格元年代币（EFYT）的持有者将会获得尔格数据（ErgoData）代币。推出时的EFYT持有者速览(snapshot)已经完成。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_07_09_after_launch/","subtitle":null,"title":"启动后的思路与尔格发展路线图"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_07_09_after_launch/","permalink":"https://ergoplatform.org/cn/news/2019_07_09/","subtitle":"非常感谢各位同业、开发者、矿工、社会各界人士以及家人在尔格开发与启动过程中所给予的大力支持与无私帮助。","title":"启动后的思路与尔格路线图"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.2","permalink":"https://ergoplatform.org/cn/news/2019_07_04/","subtitle":"该发布包括API改上","title":"尔格主网3.0.2发布"},{"contents":"","link":"https://ergoplatform.org/en/blog/2019_07_03_mining_withdrawal/","permalink":"https://ergoplatform.org/cn/news/2019_07_03/","subtitle":"本说明将帮助矿工提取其所挖到的资金","title":"尔格币提取说明"},{"contents":"花掉挖矿报酬 本文帮助矿工提取所挖到的资金。\n许多人既发布节点，又担任拥有从内嵌于节点格式化矿机获得16进制公钥（pubkeyHex）的矿工。下面我来谈一谈如何认定所挖尔格币的数量以及如何将其提取到另一个地址。\n关于密钥. 矿工可能遇到很多不同形式的密钥。\n首先，挖矿软件以及节点中的采矿支持（即：格式化文件中的 ergo.node.miningPubKeyHex 设定） 正在采用16进制编码（Base16-encoded）“原”公钥，其仅为椭圆曲线中的一个编码序列点。该密钥对矿工来说已经足够用（其可能避免支持58进制的需要，地址构成的需要等）。\n其次，节点钱包显示公钥付费（P2PK）地址，该地址以“9”开始。P2PK地址不仅包含椭圆曲线点，而且还包含网络前缀和校验和（checksum）， 类似于比特币的P2PK和P2PKH地址。\n第三，还有minig/rewardAddress API方法，其主要是针对外部工具所产生的候选区块。此种API方法看起来有点像88dhgzEuTXaSfKEbxfa6vghvEGdBH39sn9h7As2Y2Z6SGd8bKXCXmRLY5JtU4g4RYBP4WcZWb3JwjXDK，其是以编码形式支付给矿工的特殊文字。\n无论如何，如果你想把你矿机的16进制公钥（pubkeyHex）植入你的节点，完全没有问题，不用担心看到不同的密钥。\n显示你的余额以及提款 如果你先挖出来尔格币然后才进行钱包初始化，因为你进行钱包初始化的区块高度比挖币的时候要高，那么或许你看不到你挖的尔格币。请注意：节点不会对区块进行反向扫描，在初始化后，其只扫描新的区块。因此，为了找到所开采的尔格币，目前需要对整个区块链进行重新扫描（或者，如果你开采，在另一台机器上发布另一个节点，或者在格式化文件中拥有不同端口设置的同一台机器上，即，给scorex.restApi.bindAddress 和scorex.network.bindAddress的域设定新的值； 另外请使用3.0.1版本，主要是因为其更便于格式化）。\n为了把挖矿报酬花掉，你需要按照以下步骤进行操作： 1. 清除节点状态，如果你打算叫停工作节点。 为了清除你的节点的状态，你需要叫停节点，并且删除.ergo 目录下的全部内容（其可能藏在Mac和Linux你看不到的地方，尝试目录中的 ls -a 命令，你可以从此路径运行节点）。\n2.从奥托吕克斯矿机使用的种子短语中恢复本地钱包 在你格式化你的奥托吕克斯矿机时，请记住你在config.json 设定的助记符句子 - 目前你需要从那儿恢复内置钱包。为了恢复你的钱包，再次启动节点，并且将POST请求发送给含有诸如\n{ \u0026#34;pass\u0026#34;: \u0026#34;your_wallet_pass\u0026#34;, \u0026#34;mnemonic\u0026#34;: \u0026#34;mnemonic_sentense_from_your_miner\u0026#34;, \u0026#34;mnemonicPass\u0026#34;: \u0026#34;mnemonic_pass_if_set\u0026#34; } application/json 内容类型体的http://[your_node_ip]:9053/wallet/restore，\n如果 pass 是一个将用于你本地盘加密钱包数据的一把新的特殊钥匙， 并且 mnemonic 是一个你可以从奥托吕克斯矿机格式化文件(config.json)复制的助记符短语。请特别注意 mnemonicPass 的域 – 这是你的助记符短语口令，其为可选项，并且你在创造你的助记符的时候可能已经对其进行格式化。只有当你的助记符真地需要钥匙，那么就在请求中增加此域，否则就删除此域。\n不要忘记授权你的请求，设定对应 apiKeyHash正确的api_key HTTP 头字段， 在节点格式化文件中进行格式化。\n注意：为了让钱包扫描来自创世的全部区块，你需要在你的节点已经开始下载全部区块前恢复钱包（请在/info API方法回应核对fullHeight - 尽管其是 null 你的节点尚未开始下载全部区块）。\n3. 查询你的余额 当你的节点与网络实现同步的时候，请核对 /wallet/balances API方法。反馈应当类似于：\n{ \u0026#34;height\u0026#34;: 3560, \u0026#34;balance\u0026#34;: 67500000000, \u0026#34;assets\u0026#34;: {} } 首先注意 height 域 – 其应等于通过 /info API路径的 fullHeight 显示值。balance 是你钱包所发现的一个确认余额。\n4. 通过交易花掉你的报酬 为了从你的钱包中提走报酬，利用 /wallet/payment/send API路径创建一笔新的支付交易。为了进行这一操作，发送诸如\n{ \u0026#34;address\u0026#34;: \u0026#34;your_address\u0026#34;, \u0026#34;value\u0026#34;: 10000000 } 含有 application/json 内容类型体的POST请求， 如果 address 是你希望把你资金移去的地址并且 value 是你希望移走多少十亿分之一ERGs。\n在发送请求的时候，节点会回复交易ID作为回应。你可以利用 explorer 查询你的交易何时到达区块。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_07_03_mining_withdrawal/","subtitle":null,"title":"尔格提取"},{"contents":"","link":"https://twitter.com/Tidex_Exchange/status/1146161192878190594","permalink":"https://ergoplatform.org/cn/news/2019_07_02/","subtitle":"我们很荣幸地宣布尔格币($ERG) 在Tidex交易所挂牌交易","title":"尔格币($ERG) 在Tidex交易所挂牌交易"},{"contents":"","link":"https://explorer.ergoplatform.com","permalink":"https://ergoplatform.org/cn/news/2019_07_01_1/","subtitle":"尔格主网正式启动。欲了解更多详情，请点击: https://explorer.ergoplatform.com","title":"尔格主网正式启动"},{"contents":"","link":"https://explorer.ergoplatform.com","permalink":"https://ergoplatform.org/cn/news/2019_07_01_2/","subtitle":"尔格浏览器提供有关地址、区块和尔格平台交易的详细信息","title":"发布尔格浏览器"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v3.0.1","permalink":"https://ergoplatform.org/cn/news/2019_07_01/","subtitle":"该发布包括硬编码无预挖证明和创世状态根哈希，感谢所有为主网启动作出贡献的人","title":"尔格主网3.0.1发布"},{"contents":"","link":"https://p2pb2b.io/zh/","permalink":"https://ergoplatform.org/cn/news/2019_06_28/","subtitle":"尔格主链上线以后，尔格原生币(ERG)会挂牌。","title":"尔格会在P2PB2B 交易所上市"},{"contents":"自启动伊始加入尔格主网 为了在启动伊始加入尔格主网并且竞相开采创世区块，你需要按照以下步骤进行操作。如果你不打算参与尔格挖矿，而只是想建一个全节点，那么你只需进行步骤3和步骤5的操作。\n准备工作 1. 安装采矿软件 请先查阅https://github.com/ergoplatform/ergo/wiki/Mining的说明. 根据其（有关Ubuntu的）阅读说明或使用Windows手册https://ergoplatform.org/en/blog/2019_05_07_mining，搭建一个https://github.com/ergoplatform/Autolykos-GPU-miner矿机。 尝试运行诸如含有测试格式化的./auto.out config.json:\n{ \u0026#34;mnemonic\u0026#34;: \u0026#34;noise peasant subway frozen illegal pretty oak agent train valid wash title burst column yard decide move coin gas asset pretty hire happy fuel\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://159.203.36.162:9052\u0026#34;, \u0026#34;keepPrehash\u0026#34;: true } 并且查看诸如以下内容：\n2019-06-27 14:44:58,626 INFO [main thread] Using 1 GPU devices 2019-06-27 14:44:58,626 INFO [main thread] Using configuration file mine162.json 2019-06-27 14:44:58,628 INFO [main thread] Block getting URL: http://159.203.36.162:9052/mining/candidate 2019-06-27 14:44:58,628 INFO [main thread] Solution posting URL: http://159.203.36.162:9052/mining/solution 2019-06-27 14:44:58,629 INFO [main thread] Generated public key: pk = 0x03 F5214F2F6D87C714 4A2E12F8D4C4E110 1C59FF7D9AEABC11 77C4CB50FA8497E7 2019-06-27 14:44:58,714 INFO [main thread] Got new block in main thread, block data: { \u0026#34;MSG\u0026#34; : \u0026#34;3637B40440681781F92EDC92B33E623330F05705446168952CBD3720BA922442\u0026#34;, \u0026#34;B\u0026#34; : 3462030106355215694294694818737961234095984491840283822105474632310, \u0026#34;PK\u0026#34; : \u0026#34;03F5214F2F6D87C7144A2E12F8D4C4E1101C59FF7D9AEABC1177C4CB50FA8497E7\u0026#34; } 2019-06-27 14:44:58,956 INFO [GPU 0 miner] GPU 0 allocating memory 2019-06-27 14:44:58,964 INFO [GPU 0 miner] Preparing unfinalized hashes on GPU 0 2019-06-27 14:45:13,443 INFO [GPU 0 miner] GPU 0 read new block data 2019-06-27 14:48:02,298 INFO [main thread] Average hashrates: GPU0 24.8537 MH/s Total 24.8537 MH/s 上述通知表明你的矿机已经正确安装。\n2. 产生用于挖矿的助记符短语 如果你没有，请运行./auto.out –G以产生一个新的助记符短语。\n$ ./auto.out -G 2019-06-28 12:08:32,915 INFO [main thread] !!!Generated new mnemonic, put it in your config.json file!!! job great stage urge elite purity surprise any cram matrix typical table panel honey curious enlist fault matrix !!!Generated new mnemonic, put it in your config.json file!!! 2019-06-28 12:08:32,918 INFO [main thread] Generated public key: pk = 0x03 61F8098779E5EC8C 2A851E3EF57C471E 9A6803F60666E93E EB0BDD67411439D0 在上面的例子中，当你的公钥是0361F8098779E5EC8C2A851E3EF57C471E9A6803F60666E93EEB0BDD67411439D0，你所产生的助记符短语是job great stage urge elite purity surprise any cram matrix typical table panel honey curious enlist fault matrix。保存你的助记符短语（如：记在一张纸上）并且永远保存个私密的地方，任何能拿到这一信息的人都可能偷走你的钱。写下你的公钥，在接下来步骤里你需要它\n3. 格式化与开启矿机 创建一个含有以下内容的settings.json 格式化文件（别忘了替换\u0026lt;\u0026gt;括号中的内容):\n{ \u0026#34;mnemonic\u0026#34;: \u0026#34;\u0026lt;mnemonic generated at step 2\u0026gt;\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://\u0026lt;ip address of your node\u0026gt;:9053\u0026#34;, \u0026#34;keepPrehash\u0026#34;: true } 并且运行诸如./auto.out settings.json的矿机。其应进行初始化，并且开始为候选区块索取节点。\n2019-06-27 15:14:02,267 INFO [main thread] Using 1 GPU devices 2019-06-27 15:14:02,267 INFO [main thread] Using configuration file mainnet-conf.json 2019-06-27 15:14:02,269 INFO [main thread] Block getting URL: http://\u0026lt;ip address of your node\u0026gt;:9053/mining/candidate 2019-06-27 15:14:02,269 INFO [main thread] Solution posting URL: http://\u0026lt;ip address of your node\u0026gt;:9053/mining/solution 2019-06-27 15:14:02,269 INFO [main thread] Generated public key: pk = 0x02 F611D5F6AAB70C05 4A530C6420395B3C 4521642DC7125A93 49AAA2D9BB89D7AF 2019-06-28 12:21:36,035 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:36,835 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:36,876 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:37,676 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:37,718 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 不需要对矿机进行其它操作。\n4. 格式化与运行你的全节点 请先查阅https://github.com/ergoplatform/ergo/wiki/Set-up-a-full-node的说明。\n创建含有以下内容的一个settings.conf 格式化文件(别忘了替换\u0026lt;\u0026gt;括号中的内容):\nergo { node { mining = true miningPubKeyHex = \u0026#34;\u0026lt;your public key from step 2\u0026gt;\u0026#34; } chain { initialDifficultyHex=\u0026#34;011765000000\u0026#34; } } scorex { network { nodeName = \u0026#34;\u0026lt;some name to identify your node\u0026gt;\u0026#34; } restApi { # you may wish to configure an apiKeyHash to use your wallet. Check https://ergoplatform.org/en/blog/2019_06_04_wallet-documentation/ for wallet documentation.  apiKeyHash = \u0026#34;1111\u0026#34; } } 从https://github.com/ergoplatform/ergo/releases/tag/v3.0.1下载最新的主网发布，并且像nohup java -jar -Xmx3G -Dlogback.stdout.level=DEBUG ergo-3.0.1.jar --mainnet -c settings.conf那样运行，并且如果你看到类似以下内容：\n17:02:11.449 INFO [main] o.e.settings.ErgoSettings$ - Running in mainnet network mode 17:02:12.262 INFO [main] org.ergoplatform.ErgoApp - Entering coordinated network bootstrap procedure .. 17:02:12.933 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:02:22.933 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 你的节点已经完成正确格式化，不需要再进行任何其它操作。\n5. 等待主网启动 这几步完成后，你就完成了参与尔格挖矿的准备工作，你只需等待。你的矿机等待来自你节点的候选区块（block candidate），同时你的节点正在等待无预挖证明（proof-of-no-premine），该证明将由尔格开发团队根据主网启动时间表进行发布。无预挖证明将包含来自媒体（卫报、Vedomosti、新华社）的头条报道以及来自比特币和以太坊的最新区块鉴定人。在主网启动时，我们将分发无预挖证明，并且开挖启动。\n为了确保你的节点正在挖矿，你可能需要检查你的节点日志。应当停止从BootstrapController写日志，并且写Boot settings received. Starting the node, 这样日志文件将类似于以下文件：\n17:21:39.417 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:21:49.437 INFO [main] o.e.BootstrapController - Wrong response format, retrying in 10s 17:21:59.500 INFO [main] org.ergoplatform.ErgoApp - Boot settings received. Starting the node .. 17:21:59.554 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Declared address: None 17:21:59.558 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Registering handlers for List((1,GetPeers message), (2,Peers message)) 17:21:59.559 INFO [ctor.default-dispatcher-3] s.c.n.NetworkController - Successfully bound to the port 9030 17:21:59.565 INFO [ctor.default-dispatcher-4] o.e.n.state.ErgoState$ - Generating genesis UTXO state 17:21:59.568 INFO [ctor.default-dispatcher-2] o.e.local.ErgoMiner - Trying to use key from wallet for mining 17:21:59.583 INFO [ctor.default-dispatcher-3] s.c.u.NetworkTimeProvider - New offset adjusted: 2 17:21:59.585 WARN [ctor.default-dispatcher-3] o.e.n.ErgoReadersHolder - Got GetReaders request in state (None,None,None,None) 17:21:59.598 INFO [ctor.default-dispatcher-2] s.c.n.NetworkController - Registering handlers for List((55,Inv), (22,RequestModifier), (33,Modifier), (65,Sync)) 17:21:59.729 INFO [ctor.default-dispatcher-4] s.c.a.a.b.VersionedIODBAVLStorage - Update storage to version ByteArrayWrapper[6813BCA7232C6E156FB6229ECF165D157640A8576A5B320506E4C1B66011253402]: 14 elements to insert, 1 elements to remove 17:21:59.846 INFO [ctor.default-dispatcher-4] o.e.n.state.ErgoState$ - Genesis UTXO state generated with hex digest 6813bca7232c6e156fb6229ecf165d157640a8576a5b320506e4c1b66011253402 与此同时，你的矿工应当给你写下类似以下内容：\n2019-06-28 12:21:36,035 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:36,835 INFO [main thread] Waiting for block data to be published by node... 2019-06-28 12:21:36,876 ERROR [main thread] CURL: Couldn\u0026#39;t connect to server 2019-06-28 12:21:37,676 INFO [main thread] Waiting for block data to be published by node... 2019-06-27 15:26:20,328 INFO [main thread] Got new block in main thread, block data: { \u0026#34;MSG\u0026#34; : \u0026#34;0777078E22BB64C771DE8A8D3B1E454847A91024D98AB86949091C8019FA7453\u0026#34;, \u0026#34;B\u0026#34; : 964934076977634961863091541739065898773646368992290869855043026179318012, \u0026#34;PK\u0026#34; : \u0026#34;02F611D5F6AAB70C054A530C6420395B3C4521642DC7125A9349AAA2D9BB89D7AF\u0026#34; } 2019-06-27 14:44:58,956 INFO [GPU 0 miner] GPU 0 allocating memory 2019-06-27 14:44:58,964 INFO [GPU 0 miner] Preparing unfinalized hashes on GPU 0 2019-06-27 14:45:13,443 INFO [GPU 0 miner] GPU 0 read new block data 2019-06-27 14:48:02,298 INFO [main thread] Average hashrates: GPU0 24.8537 MH/s Total 24.8537 MH/s 2019-06-27 15:27:11,033 INFO [GPU 0 miner] GPU 0 found and trying to POST a solution: ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_06_28_mainnet-bootstrap/","subtitle":null,"title":"自启动伊始加入尔格主网"},{"contents":"","link":"http://github.com/ergoplatform/ergo/releases/tag/v2.2.0","permalink":"https://ergoplatform.org/cn/news/2019_06_27/","subtitle":"更新Sigma-State语言，新API方法","title":"发布“测试网2.2.0版(Testnet 2.2.0)”"},{"contents":"","link":"“http://twitter.com/ergoplatformorg/status/1143824003632685056”","permalink":"https://ergoplatform.org/cn/news/2019_06_26/","subtitle":"我们很快会指引关于在主网启动后如何迅速加入主网","title":"主网启动 ： 周一，7月1日，上午10:00 UTC"},{"contents":"","link":"https://t.me/ergo_mining","permalink":"https://ergoplatform.org/cn/news/2019_06_24/","subtitle":"欢迎CPU和GPU矿工加入","title":"尔格采矿电报(Ergo Mining Telegram)群现已开放"},{"contents":"","link":"https://twitter.com/Tidex_Exchange/status/1139282057643905024","permalink":"https://ergoplatform.org/cn/news/2019_06_14/","subtitle":"尔格原生币(ERG) 将在主网推出后立即上市","title":"EFTY（尔格元年代币）已经在Tidex挂牌上市"},{"contents":"","link":"https://twitter.com/ergoplatformorg/status/1139164264168591362","permalink":"https://ergoplatform.org/cn/news/2019_06_13/","subtitle":"由于交易所上市时间的推迟以及新发现的问题，我们已经决定将主网的推出时间推迟到6月28日进行。感谢阁下的耐心等待与长期支持！","title":"主网推出延后"},{"contents":"","link":"https://badcryptopodcast.com/2019/06/13/crypto-for-good-276/","permalink":"https://ergoplatform.org/cn/news/2019_06_13_2/","subtitle":"第276节：利用加密技术（Crypto）携手The Giving Block做善事","title":"具有尔格特征的坏加密播客(Bad Crypto Podcast)"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.1.2","permalink":"https://ergoplatform.org/cn/news/2019_06_12/","subtitle":"支持协调网络辅助程序。修复多个创世处理与地址的网络字节。","title":"发布测试网（Testnet） 2.1.2版"},{"contents":"","link":"https://www.youtube.com/watch?v=bsqcyLT8ddY","permalink":"https://ergoplatform.org/cn/news/2019_06_11/","subtitle":"比特币| DataDash所描述的货币未来的变化","title":"对为合约货币搭建框架名为“尔格”的平台所进行的访谈"},{"contents":"","link":"https://twitter.com/SwftCoin/status/1136293239219113986","permalink":"https://ergoplatform.org/cn/news/2019_06_05/","subtitle":"ERG将在主网推出后不久上市，其将可用于支付，并且与超过170种加密货币进行互换!","title":"与SWFT区块链的协议"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.1.0","permalink":"https://ergoplatform.org/cn/news/2019_06_05_3/","subtitle":"对所采用的软分叉特征进行投票表决，并且对Sigma-State语言进行更新。发布更为详细的说明。","title":"发布测试网2.1.0版"},{"contents":"","link":"https://bitcointalk.org/index.php?topic=5150971","permalink":"https://ergoplatform.org/cn/news/2019_06_05_2/","subtitle":"接着大约两年前开始的有关Bitcointalk的PRE-ANN线索来说，尔格团队宣布一个名为“尔格”对合约货币具有强适应力的平台即将上市。","title":"新的Bitcointalk线索"},{"contents":"尔格节点提供内置钱包以便存放私钥及签署交易。以下内容将说明如何建立与保护阁下的尔格钱包。\n该钱包将采用BIP39 标准从助记符句子中生出一颗种子，其将根据BIP32 标准用以创造一把私钥 （分层确定性钱包）。如果你愿意的话，你可以使用你自己的由那些词汇偏执狂常用词汇所构成的助记符句子。所允许的句子长度分别为12、15、18、21、24，分别代表128位、160位、192位、224位、256位安全。为了对这个有助记符的钱包进行初始化，你应当使用这个wallet/restoreAPI评估指标。然而，使用钱包所产生的助记符要安全得多。 在此阶段，与钱包的所有互动只能通过节点REST API完成。请确保你在进行下一步之前在你的节点上设置一把API密钥。\n钱包格式化 通过节点格式化文件对钱包进行格式化。以下是在首次钱包格式化时需要注意的格式化参数：\n ergo.wallet.seedStrengthBits - 如果其由节点产生，那么需要注意种子位的长度。注意：种子越强大，那么助记符句子的长度就会越长。选择： 128, 160, 192, 224, 256 ergo.wallet.secretStorage.secretDir - 请注意将机密以加密形式存储的目录 ergo.wallet.mnemonicPhraseLanguage - ergo.wallet.mnemonicPhraseLanguage – 请注意在助记符句子中将使用的语言。选择：\u0026quot;chinese_simplified\u0026quot;, \u0026quot;chinese_traditional\u0026quot;, \u0026quot;english\u0026quot;, \u0026quot;french\u0026quot;, \u0026quot;italian\u0026quot;, \u0026quot;japanese\u0026quot;, \u0026quot;korean\u0026quot;, \u0026quot;spanish\u0026quot;（ \u0026quot;简体中文\u0026quot;、\u0026quot;繁体中文\u0026quot;、\u0026quot;英文\u0026quot;、\u0026quot;法文\u0026quot;、\u0026quot;意大利文\u0026quot;、\u0026quot;日文\u0026quot;、\u0026quot;韩文\u0026quot;、\u0026quot;西班牙文\u0026quot;）  首次使用钱包 在首次运转节点的时候，需要通过REST API对钱包进行初始化。可以有两种选择：\n  通过向含有数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;}的/wallet/init 提出POST请求，从头开始进行初始化（种子将通过节点产生）。不要忘记存储节点对应的助记符短语。（备注：请求主题中的参数 mnemonicPass 是可选项，并且可以用来保护助记符短语）。\n  从现有的种子中恢复钱包。你需要提供你的助记符短语：什么时候使用这一选项。这可以通过向含有数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonic\u0026quot;: \u0026quot;abandon abandon ...\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;}提出 POST请求得以完成。（注意：只有当你的助记符短语在创建时被其他密码保护起来，才会需要mnemonicPass 字段）。\n  钱包开锁 在初始化后以及每次使用钱包前需要向含有数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;}的/wallet/unlock 提出 POST请求来进行解锁。（备注：在初始化阶段使用你已经选定的密码） 在每次节点重启或者钱包上锁的情况下，你必须走这一步。尤其是为了进行下列操作，钱包必须先解锁：\n 采用内部矿工 签署交易 跟踪框  钱包上锁 一段时间后钱包会自动上锁，这意味着所有当前加载的机密都将从内存中消失。你还可以通过向含有数据的/wallet/lock提出GET 请求，使用REST API 对钱包上锁。建议你在不用的时候对钱包上锁。上锁后，你需要对钱包进行重新解锁方能再次使用。\n管理密钥 钱包采用BIP32 （\u0026ldquo;分层确定性钱包\u0026rdquo;）。在钱包进行初始化的时候，只会创建根密钥。为了产生与特定衍生路径相对应的其他密钥对（方法：POST, 请求主体： {\u0026quot;derivationPath\u0026quot;: \u0026quot;m/1/2\u0026quot;}） /wallet/deriveKey API 路径可以使用。为了简化创建其他密钥对，可以使用a /wallet/deriveNextKey API 路径 （方法：GET）。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_06_04_wallet-documentation/","subtitle":null,"title":"钱包文件汇编"},{"contents":"本地交易所交易系统（LETS）旨在发展当地经济，并且通常由在彼此附近的当地人使用。 在此链接中描述了一个管理LETS的委员会。 我们将此类系统称为管理或许可，因为它取决于受信任的委员会。 在这里，我们描述了一个去信任的LETS系统，即没有管理委员会的系统。\n概要 LETS涉及多个同意使用某种形式的“本地货币”的党派，通常以1：1的比率与该国的主要货币挂钩。假设我们的LETS位于欧洲国家，货币为欧元，交换以“当地欧元”进行，被认为相当于国家欧元。\nLETS中的每个用户都有一个帐户，其中包含该用户的LETS余额（以本地欧元为单位）。在加入时，每个用户的余额为零。余额存储在（可能是去中心化的）分类帐中。 LETS的一个有趣特征是零余额的用户也可以“提款”，但仅用于支付另一个LETS用户。在任何时候，所有用户的LETS余额总和为零。\n例如，零余额的Alice希望从Bob那里以2欧元购买一升牛奶，Bob也是零余额的LETS成员。她将2欧元从她的账户转到Bob's，她的余额为-2，Bob为+2。然后，Bob可以将他的部分或全部余额转移给另一个LETS用户，以换取商品或服务。\n去信任的LETS 由于我们希望获得去信任的LETS，因此我们不能依赖任何受信任的群体来接纳用户。我们只假设又一个有信任的预言机（oracle）由一些全球账号和一个包含这个账号的一个代币的单例币箱标识。此币箱还包含在任何给定时间段内尔格币与欧元的比率。通过使用此币箱并使用新费率创建另一个单例币箱来更新费率。\n在任何情况下，我们的LETS由包含一些LETS成员资格代币的全局LETS币箱来定义。此币箱受以下脚本保护。代币账号唯一地定义了所使用的LETS的属性，例如位置，货币单位，费率预言机（oracle）账号等。一个或多个用户可以花费该币箱并创建他们各自的LETS币箱作为交易的输出。该币箱最初以例如10000 LETS会员代币开始。\n一个LETS币箱表示一个LETS成员，必须用于LETS交易。 LETS交易发生在两个LETS成员之间，一个是发送者而另一个是接收者，这样发送者将一些正数量的LETS货币（本地欧元）转移给接收者。这样的交易消耗成员的币箱并将其重新创建为具有更新余额的输出。\n基本变体 为了防止垃圾信息和分布式拒绝服务攻击，我们要求至少将一些最小数量的尔格币(minErgsToJoin)锁定在新创建的成员的币箱中。 尔格币将被锁定，直到至少minWithdrawTime数量的区块被挖掘为止。 允许一个币箱的LETS余额为负值，直至锁定的尔格币可以覆盖的金额（使用交易时的汇率）。\n// 一个币箱存储会员的代币 val tokenBox = OUTPUTS(0) // first output contains remaining LETS tokens def isLets(b:Box) = { // 一个LETS 币箱必须在代币中有正好一个会员资格代币(0)  b.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; b.tokens(0)._2 == 1 \u0026amp;\u0026amp; blake2b256(b.propositionBytes) == memberBoxScriptHash \u0026amp;\u0026amp; SELF.R4[Long].get == 0 \u0026amp;\u0026amp; // 从0 LETS结余中开始一个币箱  b.value \u0026gt;= minErgsToJoin \u0026amp;\u0026amp; // 币箱必须包含一些最小数量的尔格币  b.R6[Long].get \u0026lt;= HEIGHT // 将创建高度存储在R6中 } // 在tx中创建了多少lets币箱 val numLetsBoxes = OUTPUTS.filter({(b:Box) =\u0026gt; isLets(b)}).size // 在交易中，为币箱保留了以下内容 ... tokenBox.tokens(0)._1 == SELF.tokens(0)._1 \u0026amp;\u0026amp; // 代币账号 tokenBox.tokens(0)._2 == SELF.tokens(0)._2 - numLetsBoxes \u0026amp;\u0026amp; // 数量 tokenBox.propositionBytes == SELF.propositionBytes // 脚本 LETS成员的币框受以下脚本的保护，其哈希memberBoxScriptHash（成员币箱脚本哈希）被以上使用。\nval validRateOracle = CONTEXT.dataInputs(0).tokens(0)._1 == rateTokenID val rate = CONTEXT.dataInputs(0).R4[Int].get val inBalance = SELF.R4[Long].get // 当前输入下的LETS结余 val pubKey = SELF.R5[SigmaProp].get // 当前输入的拥有者 val createdAt = SELF.R6[Long].get // 当前输入开采的高度  val index = getVar[Int](0).get // 相关输出的指数 val out = OUTPUTS(index) val outBalance = out.R4[Long].get // 输出的LETS结余  // LETS币箱与当前币箱具有相同的脚本 val isMemberBox = {(b:Box) =\u0026gt; b.propositionBytes == SELF.propositionBytes} val letsInputs = INPUTS.filter(isMemberBox) // 所有LETS输入币箱 val letsOutputs = OUTPUTS.filter(isMemberBox) // 所有LETS输出币箱  // 如果LETS余额增加，则当前输入属于接收器 // 接收器的输入币箱中可能有一些尔格币，我们需要确保 // 接收器的输出币箱也包含与输入相同数量的尔格币 val receiver = outBalance \u0026gt; inBalance \u0026amp;\u0026amp; out.value == SELF.value val getBalance = {(b:Box) =\u0026gt; b.R4[Long].get} // 回到币箱的LETS结余  val letsBalIn = letsInputs.map(getBalance).fold(0L, {(l:Long, r:Long) =\u0026gt; l + r}) val letsBalOut = letsOutputs.map(getBalance).fold(0L, {(l:Long, r:Long) =\u0026gt; l + r}) // 发送人的币箱可以包含较少量的尔格币(发送人可以撤回提供的尔格币 // 发送者的任何负LETS余额都有足够的尔格币支持) val correctErgs = out.value \u0026gt;= -outBalance * rate \u0026amp;\u0026amp; ( out.value \u0026gt;= SELF.value || SELF.R6[Long].get + minWithdrawTime \u0026gt; HEIGHT ) // 对于接受者来说，我们并不接触尔格币的结余 // 因为接受者没有积极参与交易  inBalance != outBalance \u0026amp;\u0026amp; // 交易应该发生；结余必须变化 SELF.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; // 当前输入有正确的代币 out.tokens(0)._1 == letsTokenID \u0026amp;\u0026amp; // 对应地，输出也有正确的代币 validRateOracle \u0026amp;\u0026amp; // 预言机（oracle）提供费率具备正确的“费率代币” letsBalIn == letsBalOut \u0026amp;\u0026amp; // 总共的LETS结余被保存在交易中 letsInputs.size == 2 \u0026amp;\u0026amp; letsOutputs.size == 2 \u0026amp;\u0026amp; // 只有两个LETS输入，输出 out.propositionBytes == SELF.propositionBytes \u0026amp;\u0026amp; // 输出是一个LETS币箱 ... out.R5[SigmaProp].get == pubKey \u0026amp;\u0026amp; // ... 用正确的公钥 out.R6[Long].get == SELF.R6[Long].get \u0026amp;\u0026amp; // ... 和创建高度 (receiver || // ...要么当前输入属于接受者  (pubKey \u0026amp;\u0026amp; correctErgs) // ... 要么输出有正确的尔格币，同时tx有签名 ) 使用上述脚本支付币箱的交易需要：\n 保留了输入和输出的LETS结余之和 有两个LETS输入和两个LETS输出 公钥（存储在R5中）保存在相应的输出中 创建高度（存储在R6中）保留在相应的输出中  我们说如果输出的LETS结余高于其输入的LETS结余，则某些公钥是接收器。\n最后一个条件要求输入（和输出）币箱属于接收器（以便保留尔格币的数量），或者如果LETS余额为负，则输出由所需数量的尔格币支持。此外，它要求发送者的尔格币结余不能减少，直到在尔格币被锁定之后已经挖掘了minWithdrawTime的区块数量。\n与托管LETS相比，上述系统有以下不同之处：\n 没有会员记录：与托管LETS不同，我们不在此处存储任何会员信息。 多个币箱：一个人可以创建多个会员币箱，这是允许的。我们只要求每个币箱都锁定最小数量的尔格币。  LETS-1：零和，有抵押 以上是我们称之为LETS-1的基本变体。 它具有以下功能：\n 有时间限制的加入费：为了防止垃圾信息攻击，会员必须在加入时支付一定的最低费用。 此费用可退还，但仅限于预定数量的区块后。 零和：所有成员币箱的LETS余额总和为零。 只要在一定限度内，会员币箱就可以有负余额。 抵押品：对于发送人的输入，尔格币用作抵押品以支付当前汇率的负LETS余额。  以下是LETS-1的一些变体。\nLETS-2：零和，无抵押 这是LETS-1的略微变化如下：\n 不可退还的加入费：与LETS-1类似，需要加入费用以防止垃圾信息攻击。但是，与LETS-1不同，此费用不可退还，必须发送给某个预定义的管理委员会。 零和：与LETS-1一样。  LETS-3：正和，有抵押 以上两种变体要求总LETS余额始终为零。在这里，我们考虑这个总和的正值。特别是，此变体具有以下属性：\n 时间锁定加入费：与LETS-1相同。 正和：每个成员的LETS余额必须始终为非负数。这确保了所有成员币箱的LETS余额总和为正。初始LETS余额根据当前汇率的加入费设置为正值，上限为某个最大值。 抵押品：发送方的尔格币余额的任何减少必须伴随当前汇率的相应LETS余额的减少。  我们还可以通过添加等量的尔格币来允许在交易期间补足LETS余额。\nLETS-4：正和，无抵押 这类似于LETS-3，但有一些小的变化：\n 不可退还的加入费：与LETS-2相同 正和：与LETS-3一样  下表总结了这些变体：\n    零和 正和     有抵押 LETS-1 LETS-3   无抵押 LETS-2 LETS-4    ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_05_29-exchange/","subtitle":null,"title":"一个去信任的本地交易所交易系统"},{"contents":"概要 尔格的原生代币称为尔格币，平台的用户和矿工对其发行时间表可能非常感兴趣。尔格币也有一些独特的特征，在这篇文章中将重点展现。最基本的并且省略技术细节的特征是：尔格有严格的供应量限制，8年的发行计划、以及8年来不断下降的的发行率。所有尔格币都通过原始的专用集成电路（Asic）和池阻工作量证明（“PoW”）算法称为奥托吕科斯（Autolykos），来进行挖掘。因此，在主网启动时存在0个尔格币，因为没有首次币发行也没有预挖。在8年结束时，最终的尔格币供应将是97,739,925个尔格币。尔格区块间距为2分钟，前两年每个区块将释放总共75个尔格币，供矿工和金库共享（下文讨论的金库）。但从第2年开始，发行率将下降3.0 个尔格币，然后每3个月进一步下降3.0个尔格币，这将导致在发行8年后结束发行。不会有额外的通货膨胀，而且尔格币基础货币将保持不变。下面的发行图说明了这一点。\n尔格金库 为了资助开发，推广，活动，将尔格的“尔格元年代币”（“EFYT”，Ergo First Year Token下文进一步讨论）交换为尔格币并为可能推进该平台的其他活动提供资金，尔格已经建立了一个金库，将获得尔格币总发行量的4.43％。在主网发布后的前两年，金库每个区块将获得7.5个尔格币。鉴于每个区块的区块奖励总计为75个尔格币，金库的尔格币分配相当于前两年总区块奖励的10％，并且矿工的区块奖励为每区块67.5个尔格币。 2年后，金库将继续获得超过67.5个尔格币的部分奖励，但是，当区块奖励达到每个区块66个尔格币时，2年半之后将变为0。熟悉其他一些带有金库的工作量证明协议的读者，如ZCash，可能会发现与之类似，但应该注意的是进入金库的尔格币总数仅为4,330,791.5，占总货币金额的4.43％，并在短短2年半完成。这与ZCash的金库相比，后者是ZCash总货币金额的10％和前4年所有ZCash币的20％。希望在主网发布一年后，尔格将通过多元化的开发商，矿工和用户群实现高水平的去中心化。第一年，金库将用于在尔格币的Waves（波）平台上交换尔格元年代币（EFYT）。在剩余的1年半内，将建立一个社区投票机制，以确定金库的资金支出情况。\n尔格发行图表和代码 发行计划的代码可以从此处获得\n尔格元年代币（“EFYT”Ergo First Year Token） 2年前，即2017年5月，从10万个“尔格元年代币”（“EFYT”）空投开始，尔格元年代币在Waves DEX上进行了空投和分发。尔格元年代币有助于建立尔格利益相关者和爱好者的早期社区以及筹集少量资金的双重目的。该平台在发布之前用于资助开发，推广等。尔格元年代币严格来说是一个Waves代币，与尔格币不同，尔格币是在尔格主网发布后挖掘的尔格主网本地代币。\n尔格元年代币将与主网发布后的前1年内开采的尔格币的一小部分进行交换。执行交换的计划机制首先是，将在Waves上为尔格的主网代币尔格币建立一个新的支付网关。有关Waves支付网关的更多信息，请点击此处。在建立网关后，当尔格金库从挖矿奖励中收到尔格币时，金库将通过网关将这些尔格币存入Waves，此时，金库将以1.00 尔格币/1.00EFYT的固定价格在市场上出价。尔格元年代币的所有者可以将他们的尔格元年代币交换为尔格币，并按照他们的意愿与他们的包含保存在Waves的尔格币进行交换，在Waves上交易或通过网关将他们的尔格币从Waves转移到他们自己的钱包以便在其他地方使用。在这个过程中由金库购买的所有尔格元年代币都将被烧掉。\n尔格元年代币的当前分发情况可以在这里找到。值得注意的是，尔格元年代币的最大供应量为1,970,945.0。这是尔格代币发行第一年的10％和金库将获得的尔格币数量相同，这意 味着 金库将在第1年收到1,970,945.0个尔格币，足以将尔格元年代币的最大供应量交换为尔格币。\n尔格如何在短短8年内发行整个尔格币供应，而其他工作量证明区块链的发行时间表更长？ 除了尔格之外，很少有（如果有的话）工作量证明协议仅有8年之短的发行时间表，尔格之所以能做到的原因是值得一提的。首先，简单地和一些突出的工作量证明和最近发布的工作量证明代币作比较，尔格币供应量在8年后完成100％发行，无长尾发行，而以下代币的发行是这样的：\n 比特币在8年后发行约75％，随后长尾发行; ZCash和Ravencoin遵循与比特币相同的发行计划; Beam将在8年后发行75％并具有长尾发行; Grin通胀无限期延长。  尔格的短发行计划是通过其新的经济模式实现的，即其协议的存储租用费特征。矿工将有一个额外的收入来源，这里有一篇相关论文。总而言之，矿工能够从未使用的币箱（类似于比特币中的UTXO）中每隔4年扣除一次在尔格币中计算的存储租用费，以换取将这种币箱保持在高成本记忆中的状态。因此，即使在没有区块奖励补贴的情况下，矿工也会受到高度激励以确保网络安全，这将导致更稳定的挖矿奖励，而不仅仅依靠矿工也能获得的交易费用。拥有存储租用费的其他好处包括防止“状态膨胀”、建立一个状态周边的经济（用户必须付钱以保持矿工记忆中未用完的币箱）以及任何丢失的硬币逐渐返回循环。请注意，在尔格生态中，矿工可以使用在线投票来逐步更改许多关键参数，包括存储租用费、区块大小和区块的最大计算成本。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_05_20-curve/","subtitle":null,"title":"尔格发行计划"},{"contents":"","link":"https://ergoplatform.org/docs/whitepaper_Ergo_cn.pdf","permalink":"https://ergoplatform.org/cn/news/2019-05-15-whitepaper/","subtitle":"尔格平台深层概述","title":"尔格白皮书"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/news/2019-05-07-release/","subtitle":"由于主要集中在测试和安全审核等方面的原因，我们决定将主链上线日期延迟到6月20日。","title":"主链延迟发布"},{"contents":"第1步：工具 Visual Studio(可视化工作室)\n选择免费的社区版本，您需要在安装期间选择使用C ++包进行桌面开发。\nCUDA工具包 选择您的系统版本，使用默认选项安装，它会将您的图形驱动程序更新为兼容版本。\nCurl\n没有SSL的通用版本，二进制不会工作。 选择通用源，压缩文件并单击显示镜像。下载并解压缩。\nOpenSSL 1.0.2\n下载并安装。\nAutolykos GPU矿工\n单击克隆或下载，并下载压缩文件并解压缩。\n第2步：构建libcurl 打开命令行，转到 c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\vc\\Auxiliary\\Build\\ 并运行此脚本： vcvarsall.bat x64\n打开命令行，转到解压缩的Curl目录，然后进入winbuild文件夹并运行此命令： nmake /f Makefile.vc mode=dll MACHINE=x64\n成功构建后，转到Curl目录， \\curl\\builds\\libcurl-vc-x64-release-dll-ipv6-sspi-winssl\\bin 并将 libcurl.dll 复制到 \\Autolykos\\secp256k1 目录。\n第3步：建立矿工 打开命令行，转到 c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\vc\\Auxiliary\\Build\\ 并运行此脚本： vcvars64.bat\n打开命令行并转到解压缩的奥托吕科斯图形处理器矿工（Autolykos GPU miner）目录，然后进入 secp256k1文件夹 并编辑 winbuild.cmd 文件，将 OPENSSL_DIR, LIBCURL_DIR 更改为OpenSSL和Curl主目录。 您可以将 CUDA_COMPUTE_ARCH 更改为所需的图形处理器代码体系结构。\n运行 winbuild.cmd 并构建你的矿工。 成功构建后，您应该能在同一目录中发现miner.exe。\nS第4步：挖掘 在挖掘之前，您必须配置您的节点，钱包和矿工 \n同步节点后，配置并解锁钱包，您必须在 \\Autolykos\\secp256k1 目录中，创建挖掘配置文件 config.json ，具有以下结构： {“seed”：“YourSeedString”，“node”：“https：//127.0.0.1：9052” ，“keepPrehash”：true}。\n打开命令行并转到 \\Autolykos\\secp256k1 目录。 运行 miner.exe config.json。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_05_07_mining/","subtitle":null,"title":"如何在Windows（x64）系统下挖掘尔格"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/foundation/","subtitle":"Foundation page","title":"Foundation"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/legal/","subtitle":"Legal page","title":"Legal"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/privacy/","subtitle":"Privacy page","title":"Privacy"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/use_cases/","subtitle":"Use Cases page","title":"Use Cases"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/wallets/","subtitle":"Wallets page","title":"Wallets"},{"contents":"","link":"https://ergoplatform.org/docs/teaser_cn.pdf","permalink":"https://ergoplatform.org/cn/news/2019-04-24-teaser/","subtitle":"高度概括了该平台的愿景、共识机制、客户端、存续性、经济模型及应用前景。","title":"尔格简介"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/software/","subtitle":"Software page","title":"Software"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/basics/","subtitle":"Basics page","title":"Basics"},{"contents":"本地交易所交易系统（LETS）是一个本地相互信用协会，允许成员单独创建共同信用资金，系统中的所有交易都写入共同的分类账。例如，假设拥有零余额的Alice愿意从Bob购买一升生鲜奶。首先，他们就价格达成一致，例如，假设价格约为2欧元（Alice和Bob居住在爱尔兰）。交易被写入分类账后，Alice的余额变为-2（减去2）欧元，Bob的余额变为2欧元。然后Bob可能会花费2欧元来购买Charlie的自制啤酒。通常，这种制度对负余额施加限制，有时甚至对正余额施加限制，以促进社区交易。\n从历史上看，这种系统在危机时期变得流行起来。第一个系统是迈克尔林顿于1981年在加拿大陷入萧条时的城镇建立的。1998-2002年阿根廷大萧条期间，当地的交易所交易系统非常受欢迎。大多数LETS团体的成员从50到250人不等，由核心委员会维护纸质信用票据和分类账。然而，基于纸张的LETS货币已经出现了一些问题，例如伪造票据，系统管理员可能的流氓行为等等。因此，基于区块链的LETS可能优于旧系统。有关LETS的更多信息可以在“货币生态”(The Ecology of Money”)一书(作者RichardDouthwaite) 和维基百科中找到。\n在本文中，我们将展示如何在尔格之上实现LETS。据我们所知，这是区块链上首次执行这种社区货币。我们的参考执行很简单，包括两个合同，即管理合同和交易合同。我们跳过尔格初步行动，所以请起步者阅读 首次币发行文章和ErgoScript教程(基础和 高级)。不过，我们将在以下句子中介绍几个新术语。如果发出的代币数量等于1，我们将其称为单例代币。类似地，包含单例代币的币箱称为单例币箱。\n管理合约控制一个单例币箱，该币箱容纳LETS系统的会员。合约允许以每笔交易一个会员的速度添加新会员。该币箱不存储会员，而是仅构建在会员目录之上的经过验证的数据结构的小摘要。会员与在交易中发出的单例代币相关联，该交易将会员添加到目录中。该交易创建一个新会员的币箱，其中包含会员的单例代币。会员的盒子受交换合同的保护。此外，新创建会员币箱的初始余额写入R4寄存器，在我们的示例中余额等于零。创建新会员的交易必须提供目录转换的正确性证明。\n管理合约币箱通常由委员会控制，委员会随着时间的推移而发展。为了支持这一点，我们允许委员会逻辑驻留在寄存器R5中。例如，假设已添加新的委员会会员以及新的LETS会员，输入管理合约币箱需要2/3个签名，输出币箱需要3/4个签名。在这种情况下，输入和输出币箱中R5寄存器的内容会有所不同。\n下面提供了尔格脚本中带有注释的管理合约代码。请注意“userContractHash”（用户合约哈希）是关于交易合约哈希。\nval selfOut = OUTPUTS(0) // 管理脚本  val managementScript = selfOut.R5[SigmaProp].get // 管理脚本模板正在自我复制，并且管理脚本已被满足  val scriptCorrect = (selfOut.propositionBytes == SELF.propositionBytes) \u0026amp;\u0026amp; managementScript // 支出交易正在为目录，用户，费用创建币箱。  val outsSizeCorrect = OUTPUTS.size == 3 // 检查管理标签代币是否正在自我复制  val outTokenCorrect = (selfOut.tokens.size == 1) \u0026amp;\u0026amp; (selfOut.tokens(0)._1 == letsToken) // 检查新代币是否发行，其数量是否正确  // OUTPUTS(0) 已经通过outtokenCorrect检查了代币  val issuedTokenId = INPUTS(0).id val userOut = OUTPUTS(1) val correctTokenAmounts = (userOut.tokens.size == 1 \u0026amp;\u0026amp; userOut.tokens(0)._1 == issuedTokenId \u0026amp;\u0026amp; userOut.tokens(0)._2 == 1 \u0026amp;\u0026amp; OUTPUTS(2).tokens.size == 0 \u0026amp;\u0026amp; outTokenCorrect) // 检查是否已使用零余额创建新用户  val zeroUserBalance = userOut.R4[Long].get == 0 val properUserScript = blake2b256(userOut.propositionBytes) == userContractHash // 检查新代币标识符是否已添加到目录中  val selfTree = SELF.R4[AvlTree].get val toAdd: Coll[(Coll[Byte], Coll[Byte])] = Coll((issuedTokenId, Coll[Byte]())) val proof = getVar[Coll[Byte]](1).get val modifiedTree = selfTree.insert(toAdd, proof).get val expectedTree = selfOut.R4[AvlTree].get val treeCorrect = modifiedTree == expectedTree correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript correctTokenAmounts \u0026amp;\u0026amp; scriptCorrect \u0026amp;\u0026amp; treeCorrect \u0026amp;\u0026amp; zeroUserBalance \u0026amp;\u0026amp; properUserScript 交易合约脚本非常简单，下面提供了描述其逻辑的注释。 在合约中，假设交易合约币箱的支出交易正在接收至少两个输入，并且前两个输入应受交易合约脚本保护并包含LETS成员代币。 要检查输入中的单例会员标记是否确实属于LETS系统，开销交易会将管理合约币箱作为第一个只读数据输入，并且还应提供会员标记确实属于经过验证的目录的证据。 通过管理合约币箱的R4注册。 脚本中的“letsToken”是关于管理币箱的单例代币。\n// LETS交易者允许的最小余额  val minBalance = -20000 val lookupProof = getVar[Coll[Byte]](1).get // 包含LETS会员目录的只读币箱  val treeHolderBox = CONTEXT.dataInputs(0) val properLetsToken = treeHolderBox.tokens(0)._1 == letsToken val membersTree = treeHolderBox.R4[AvlTree].get // 支出交易需要愿意交易的LETS会员的两个币箱，  // 并返回修改余额的币箱。  val participant0 = INPUTS(0) val participant1 = INPUTS(1) val participantOut0 = OUTPUTS(0) val participantOut1 = OUTPUTS(1) //检查成员是否确实属于LETS  val token0 = participant0.tokens(0)._1 val token1 = participant1.tokens(0)._1 val memberTokens = Coll(token0, token1) val membersExist = membersTree.getMany(memberTokens, lookupProof).forall({ (o: Option[Coll[Byte]]) =\u0026gt; o.isDefined }) // 检查交易期间LETS会员余额的变化是否正确  val initialBalance0 = participant0.R4[Long].get val initialBalance1 = participant1.R4[Long].get val finishBalance0 = participantOut0.R4[Long].get val finishBalance1 = participantOut1.R4[Long].get val diff0 = finishBalance0 - initialBalance0 val diff1 = finishBalance1 - initialBalance1 val diffCorrect = diff0 == -diff1 val balancesCorrect = (finishBalance0 \u0026gt; minBalance) \u0026amp;\u0026amp; (finishBalance1 \u0026gt; minBalance) \u0026amp;\u0026amp; diffCorrect // 检查会员币箱是否保存了脚本。  // todo：可以在这里进行优化  val script0Saved = participantOut0.propositionBytes == participant0.propositionBytes val script1Saved = participantOut1.propositionBytes == participant1.propositionBytes val scriptsSaved = script0Saved \u0026amp;\u0026amp; script1Saved // 会员特定的币箱保护  val selfPubKey = SELF.R5[SigmaProp].get selfPubKey \u0026amp;\u0026amp; properLetsToken \u0026amp;\u0026amp; membersExist \u0026amp;\u0026amp; diffCorrect \u0026amp;\u0026amp; scriptsSaved 请注意，可以通过多种方式修改这两个合约，以获得具有不同属性的新系统。 所以希望有一天这篇文章会有后续！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_04_22-lets/","subtitle":null,"title":"尔格之上的本地交易所交易系统"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/news/","subtitle":null,"title":"News"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/faq/","subtitle":"Frequently asked questions page","title":"Faq"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/404/","subtitle":null,"title":"404"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/contribute/","subtitle":"Contribute page","title":"Contribute"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/documents/","subtitle":"Documents page","title":"Documents"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/blog/","subtitle":null,"title":"Blog"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/hall_of_fame/","subtitle":"Hall of Fame page","title":"Hall of Fame"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/about/","subtitle":"About page","title":"About"},{"contents":"本文介绍了在尔格脚本中执行的功能齐全的ICO（首次币发行）。该案例涵盖了尔格平台的几个重要和新颖的特征，并展示了如何使用少量代码来支持复杂的合约。\n第1部分。初步行动 加密货币协议中的一个重要设计决策是指定支出交易实际花费的内容。这里有两种可能性。第一个基于UTXO(未花费的交易输出）的模型，如在比特币中，交易花费一次性资产容器（在比特币中称为'硬币'或UTXO）并创建新的。另一种是基于账户的模型，如在Nxt，以太坊或Waves中，交易将一定数量的资产从现有长存的账户转移到另一个，可能是新的长存的账户，这后续可能产生副作用，例如Waves或以太坊中的合同执行。在这方面，尔格类似于比特币，因为它使用基于UTXO的方法，其中一次性容器被称为币箱。有趣的是，尔格交易还可以有未被花费的数据输入，而是用于从当前未使用的币箱来提供一些信息。\n在基于UTXO的模型之上创建首次币发行并非易事，因为与基于帐户的模型相比，此处没有明确的持久存储。但是，尔格将支出交易带入脚本的执行上下文中。通过这种小的改变，可以表达交易输出和输入之间的依赖关系。反过来，通过设置依赖关系，我们甚至可以在区块链上执行任意复杂的图灵完备程序（参见\u0026ldquo;自我复制硬币作为通用图灵机\u0026rdquo;论文）。在本文中，我们将使用ICO定义多阶段合同的具体方案，其中我们有三个阶段（融资，代币发行，退出）。\n现在想象一下成千上万参与者的ICO。与以太坊不同，尔格不提供存储大量数据的可能性，并且在整个合同执行过程中都可以存储它们。相反，它允许仅存储数据结构的大约40字节的头，表示为键 - \u0026gt;值字典，与默克尔树类似地进行验证。要访问字典中的某些元素或对其进行修改，触发保护脚本执行的支出交易应提供查找或修改证明。这为合同提供了对潜在巨大数据集进行验证的可能性，而无需太多内存来存储合约状态。但是，在（活动合约）状态下存储空间意味着更大的交易，但从可扩展性的角度来看，这个问题更容易，并且可扩展性是尔格的首要任务。\n第2部分.首次币发行（ICO）合同 可能存在许多与首次币发行（ICO）相关的可能情景。在本文中，我们考虑一个首次币发行想要收集至少一定数量的资金（尔格币）来启动项目。一旦超过资金门槛并且资金期结束，该项目就会启动，并且项目将根据所收集的资金总额发放首次币发行的代币。在永久延续的退出阶段，投资者根据他们在融资期间投入的金额撤回首次币发行的代币。下面简要介绍合约步骤，并进一步提供详细信息：\n 首先，融资期开始。它从一个项目币箱开始，对一个空字典进行验证。该词典用于持有（投资者，平衡）对，其中投资者是保护包含退出代币的币箱的脚本。为了平衡，我们假设在ICO期间1个代币等于1个尔格。在融资期，只有将尔格币放入项目的框中才有可能。资金交易花费在项目的框中，并创建一个包含更新信息的新项目框。为此，项目币箱的支出交易还有使投资者撤回脚本的其他输入。应将投资者脚本和输入值添加到新币箱的树中。这将会有许多链式资金交易。 其次，融资期结束，之后持有投资者数据的树变为只读。经过验证的树可以单独允许不同的修改操作：可以禁止插入，删除，更新或所有操作（因此树可以处于只读模式）。此外，此交易还会创建首次币发行项目的代币，该项目将在下一阶段退出。该项目可以在此阶段撤回尔格币。 第三，投资者撤回他们的首次发行币代币。为此，支出交易创建具有保护条件的输出和从树中获取的标记值。撤回的对也从树中清除。可能会有许多链式支出交易。  这三个阶段应按逻辑顺序链接在一起。使用一系列币箱来实现这些目标。\n第3部分.首次币发行合约细节 下面提供ICO合约阶段的细节和尔格脚本代码。\n融资阶段 在先期的融资阶段，我们假设最初项目创建了一个提交到空字典（存储在寄存器R5中）的币箱，其中包含下面描述的一些保护脚本。这个阶段至少持续到2,000高度。更具体地说，高度为2,000或更高的第一个交易应该更改输出币箱的脚本，如下一节所述（较低高度的交易必须输出具有相同脚本的币箱）。\n项目币箱检查它是否始终是交易的第一个输入和输出。 其他输入被视为投资者的输入。 投资者的输入包含寄存器R4中的脚本的哈希。 此哈希表示将在稍后的退出阶段使用的退出脚本。 应将所有投资输入的哈希值和货币值添加到字典中。 支出交易提供了证明投资者数据确实被添加到字典中的证据，并且在合同中检查证明。\n在资助分包合约中没有检查字典是否只允许插入，而不是更新现有值或删除（尽管添加显式检查并不困难）。\n支出交易应该支付费用，否则，它不太可能包含在一个区块中。因此，资助合同检查支出交易有两个输出（一个用于自身，另一个用于支付费用），费用不超过一定限度（在我们的例子中只有一个纳米），并且保护命题应该是这样只有矿工可以花费输出（在我们的例子中，我们只使用来自编译环境的变量“feeProp”而不提供任何细节）。这个“feeProp”对应于一个标准，虽然不是协议所要求的。\n下面的代码强制执行上述条件。请注意，“nextStageScriptHash”（下一步脚本哈希）环境变量包含颁发阶段序列化脚本的哈希值。\nval selfIndexIsZero = INPUTS(0).id == SELF.id val proof = getVar[Coll[Byte]](1).get val inputsCount = INPUTS.size val toAdd: Coll[(Coll[Byte], Coll[Byte])] = INPUTS.slice(1, inputsCount).map({ (b: Box) =\u0026gt; val pk = b.R4[Coll[Byte]].get val value = longToByteArray(b.value) (pk, value) }) val modifiedTree = SELF.R5[AvlTree].get.insert(toAdd, proof).get val expectedTree = OUTPUTS(0).R5[AvlTree].get val properTreeModification = modifiedTree == expectedTree val outputsCount = OUTPUTS.size == 2 val selfOutputCorrect = if(HEIGHT \u0026lt; 2000) { OUTPUTS(0).propositionBytes == SELF.propositionBytes } else { blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash } val feeOutputCorrect = (OUTPUTS(1).value \u0026lt;= 1) \u0026amp;\u0026amp; (OUTPUTS(1).propositionBytes == feeBytes) val outputsCorrect = outputsCount \u0026amp;\u0026amp; feeOutputCorrect \u0026amp;\u0026amp; selfOutputCorrect selfIndexIsZero \u0026amp;\u0026amp; outputsCorrect \u0026amp;\u0026amp; properTreeModification 发行阶段 这个阶段只有一个支出交易进入下一阶段（退出阶段）。支出交易进行以下修改。首先，它将字典上允许的操作列表从“仅插入”改为“仅删除”，因为下一阶段（退出）仅处理从字典中删除条目。\n其次，合同检查是否发行了适当数量的首次币发行的代币。在尔格中，允许每个交易发出一种新的代币，代币的标识符应该等于第一个输入币箱的（唯一）标识符。发行分包合同检查已发出新代币，其金额等于首次币发行迄今为止收集的纳米级数量。\n第三，合约检查支出交易确实正在重新创建具有对应于下一阶段（退出阶段）的保护脚本的币箱。\n最后，项目应该撤回收集的尔格币，当然，每次支出交易都应该支付费用。因此，分包合约检查支出交易确实有3个输出（项目代币币箱，尔格币撤回币箱和费用币箱各一个），并且第一个输出和输出带有发行的代币。由于我们没有指定项目资金撤回细节，我们需要在支出交易上签署项目签名。\nval openTree = SELF.R5[AvlTree].get val closedTree = OUTPUTS(0).R5[AvlTree].get val digestPreserved = openTree.digest == closedTree.digest val keyLengthPreserved = openTree.keyLength == closedTree.keyLength val valueLengthPreserved = openTree.valueLengthOpt == closedTree.valueLengthOpt val treeIsClosed = closedTree.enabledOperations == 4 val tokenId: Coll[Byte] = INPUTS(0).id val tokensIssued = OUTPUTS(0).tokens(0)._2 val outputsCountCorrect = OUTPUTS.size == 3 val secondOutputNoTokens = OUTPUTS(0).tokens.size == 1 \u0026amp;\u0026amp; OUTPUTS(1).tokens.size == 0 \u0026amp;\u0026amp; OUTPUTS(2).tokens.size == 0 val correctTokensIssued = SELF.value == tokensIssued val correctTokenId = OUTPUTS(0).R4[Coll[Byte]].get == tokenId \u0026amp;\u0026amp; OUTPUTS(0).tokens(0)._1 == tokenId val valuePreserved = outputsCountCorrect \u0026amp;\u0026amp; secondOutputNoTokens \u0026amp;\u0026amp; correctTokensIssued \u0026amp;\u0026amp; correctTokenId val stateChanged = blake2b256(OUTPUTS(0).propositionBytes) == nextStageScriptHash val treeIsCorrect = digestPreserved \u0026amp;\u0026amp; valueLengthPreserved \u0026amp;\u0026amp; keyLengthPreserved \u0026amp;\u0026amp; treeIsClosed projectPubKey \u0026amp;\u0026amp; treeIsCorrect \u0026amp;\u0026amp; valuePreserved \u0026amp;\u0026amp; stateChanged 退出阶段 在此阶段，允许投资者撤回受预定义保护脚本（其哈希存储在字典中）保护的项目令牌代币。 退出是按N个数量的批次进行的。因此，撤回交易有N + 2个输出，其中第一个输出优先于提取分包合同和余额标记，最后一个输出支付费用，其余N个输出有根据字典保护脚本和标记值。 合同需要两个字典元素的证明：一个证明要撤回的值确实在字典中，第二个证明得到的字典没有撤销的值。 分包合约如下。\nval removeProof = getVar[Coll[Byte]](2).get val lookupProof = getVar[Coll[Byte]](3).get val withdrawIndexes = getVar[Coll[Int]](4).get val out0 = OUTPUTS(0) val tokenId: Coll[Byte] = SELF.R4[Coll[Byte]].get val withdrawals = withdrawIndexes.map({(idx: Int) =\u0026gt; val b = OUTPUTS(idx) if(b.tokens(0)._1 == tokenId) { (blake2b256(b.propositionBytes), b.tokens(0)._2) } else { (blake2b256(b.propositionBytes), 0L) } }) val withdrawValues = withdrawals.map({(t: (Coll[Byte], Long)) =\u0026gt; t._2}) val withdrawTotal = withdrawValues.fold(0L, { (l1: Long, l2: Long) =\u0026gt; l1 + l2 }) val toRemove = withdrawals.map({(t: (Coll[Byte], Long)) =\u0026gt; t._1}) val initialTree = SELF.R5[AvlTree].get val removedValues = initialTree.getMany(toRemove, lookupProof).map({(o: Option[Coll[Byte]]) =\u0026gt; byteArrayToLong(o.get)}) val valuesCorrect = removedValues == withdrawValues val modifiedTree = initialTree.remove(toRemove, removeProof).get val expectedTree = out0.R5[AvlTree].get val selfTokensCorrect = SELF.tokens(0)._1 == tokenId val selfOutTokensAmount = SELF.tokens(0)._2 val soutTokensCorrect = out0.tokens(0)._1 == tokenId val soutTokensAmount = out0.tokens(0)._2 val tokensPreserved = selfTokensCorrect \u0026amp;\u0026amp; soutTokensCorrect \u0026amp;\u0026amp; (soutTokensAmount + withdrawTotal == selfOutTokensAmount) val properTreeModification = modifiedTree == expectedTree val selfOutputCorrect = out0.propositionBytes == SELF.propositionBytes properTreeModification \u0026amp;\u0026amp; valuesCorrect \u0026amp;\u0026amp; selfOutputCorrect \u0026amp;\u0026amp; tokensPreserved 可能的增强 请注意，我们的示例合约忽略了许多细微差别。 例如，任何听从区块链的人都可以在融资和退出阶段执行合约并构建适当的支出交易。 在现实世界中，可能需要使用来自项目或可信决定者的附加签名。\n此外，在退出合同中没有考虑自毁案件，因此它将一直存在，直到被矿工通过存储租用机制销毁，可能持续数十年甚至数百年。对于融资阶段，从项目中获得额外的输入是合理的，其值等于费用输出的值。 等等。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_04_10-ico-example/","subtitle":null,"title":"一个尔格顶层的首次币发行案例"},{"contents":"概况介绍 挖矿，是指在Ergo区块链上进行一系列资源密集的计算来加入新区块的过程。\nErgo挖矿基于Autolykos, 一个旨在抵抗ASIC超级矿机和矿池的工作量证明（PoW）算法。矿工们要进行内存硬计算（至少需要2GB内存，4-8GB的RAM是目前效率最高的配置）因此Ergo对于GPU挖矿十分友好。此外，Autolykos需要接入私钥，由此防止挖矿池的形成。一旦找到正确的算法，矿工即可散播他的区块（连同算法一起散播），在720个区块后拿到他相应的奖励。余下全网将用该矿工的公钥对该算法进行验证，验证的过程需要较少的内存千字节，效率相当高。\n如何进行Ergo挖矿 Ergo挖矿需要一个配置并同步过的Ergo节点，还有至少一个GPU，来完成实际的PoW计算。当然了，你可以用多个GPU倍增哈希算力，但你仅需一个Ergo节点。\n设置全节点 全节点设置可参见上一个章节（教程一：如何设置全节点）。要支持一个外部矿工，也就是我们会用到的，你的配置文件里要有以下设置：\nergo.node.mining = true ergo.node.useExternalMiner = true 如果你已经有了私钥/公钥对，你可以在节点配置里指定公钥或地址：\nergo.node.miningPubKeyHex = \u0026#34;11aa ... FF\u0026#34; 如果这个参数没出现，节点会采用内置钱包里第一个公钥来为外部矿工生成区块。\n只要节点同步完成，你就完成挖矿的准备工作了。\n设置矿工 警告！ ⚠️ 由于Autolykos要用到私钥，切勿切勿使用非受信任的挖矿软件。一定要检查软件是否开源，是否已被社区认可，这非常重要！\n从以下挖矿软件里安装你的软件：\n CUDA miner (Nvidia GPU only)  挖矿配置文件如下：\n{ \u0026#34;seed\u0026#34;: \u0026#34;注意！！！ 将此替换为您的助记句并保密，否则您将被抢劫\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;http://188.166.89.71:9052\u0026#34;,\u0026#34;keepPrehash\u0026#34;: false } 定义：\n 种子 是节点配置里的助记句，或是该设置里能为miningPubKeyHex计算私钥的助记句 节点 是您的节点API端口的URL 保留预哈希（keep Prehash）是一个优化参数。如果设定成 true, 矿工会消耗最多8GB内存。如果设定成 false 矿工会消耗最大4GB内存，但其表现也会打25%左右折扣。  现在，用矿机运行指令 ./auto.out config.json (用Linux)，尽情享受区块奖励吧！\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_04_03_mining/","subtitle":null,"title":"如何进行Ergo挖矿"},{"contents":"","link":"https://ergoplatform.org/cn/blog/2019_04_03_mining/","permalink":"https://ergoplatform.org/cn/news/2019-04-03-ergo-mining-tutorial/","subtitle":"通过完成算力密集的计算，向区块链上增加新的区块，这就是Ergo上的挖矿过程","title":"尔格挖矿教程"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.0.3","permalink":"https://ergoplatform.org/cn/news/2019-04-02-testnet-2.0.3/","subtitle":"测试网2.0.3版本正式发布，修复多个已知漏洞，增加支持GPU挖矿功能。","title":"测试链2.0.3发布"},{"contents":"首先，我们有一个重要的公告—如果在审计过程中没有发现安全漏洞，计划于5月26日发布尔格主网！\n关于扩展和应用的愿景是什么？ 关于扩展，主要方法是在不影响功能的情况下避免膨胀。例如。持久可更新存储是可能的，更新由区块链合约检查，但只有验证了的数据结构的摘要（以及一些额外的字节，少于40个字节）存储在UTXO集，这与数据集的大小无关。存储租金有助于清除UTXO设备上的灰尘。轻量客户端：在尔格中，如果你不使用，你可以在不存储UTXO设置的情况下获得全节点保证。这大大改善了boostrapping（机器学习算法）和区块验证时间。通过这些改进，可以在不影响经典区块链假设和保证的情况下提高TPS（透明页共享）。但是你想要具体数字吗？我没有具体数字，因为区块大小等参数不是一成不变的，而是矿工可以调整它们。因此，如果矿工正在经历低的完整区块验证时间（硬件随着时间的推移而变得越来越好，软件也是），他可能会建议或投票来增加区块大小。\n关于应用，我们希望有人追随：1。人们重视系统及其用户之间的社会契约。例如。人们对以太坊分叉不满意。尔格不会有硬件更新功能，而社区可以在很多方面升级协议。 2.由于（1）至少，同时也有限的供应，尔格将作为储值资产（如果您只是在系统中存储硬币，滞期费用很少）。3.需要安全，简单和高效的金融应用的人员。尔格的智能货币概念比以太坊的智能合约简单得多，同时功能强大，足以满足那些没有特定技术开发固态合约的人们的大多数金融应用，或大量资金来雇用熟练的开发人员。 4.还没准备好预测大公司的任何事情，但有些企业已表示有兴趣在尔格之上做一些代币和合约。我们会尽早宣布任何相关事宜。\n有没有示例或用例？ 我们有很多示例，合约：预言机（oracles），众筹，原子交叉链和单链（代币到代币）交换，混合等。 开发人员的尔格脚本教程涵盖了基础信息。\n一个包含更复杂示例的文件（冷钱包，混合，石头剪刀布游戏）即将发布。此外，我们将展示首次币发行场景和LETS系统的示例。 另请参阅\u0026ldquo;为大众提供智能合约\u0026rdquo;博文中的目标小额信贷合约示例。\n您是否有意建立像闪电网络这样的本地链下解决方案？您对社区驱动方案的看法是什么？ 是的，我们希望它们会在某个时刻出现。我们现在的目标是提供尽可能灵活的协议，使其实现变得容易。最重要的是，我们已经有社区成员在尔格之上执行侧链，但这项工作还处于早期阶段。我们支持社区的任何活动，包括侧链。\n哪个区块链项目与尔格类似？ 在某些方面，比特币（软分叉，但我们会更进一步），Coda（如果它是真实的，我仍需检查;轻量客户端），Grin（FlyClient类似于PoPoWs），ZCash（Equihash是类似于我们的工作量证明，但我们的参数更严格，我们的工作量证明是池阻的）。不能像我们的语言一样命名任何其他项目！所以，总的来说，尔格非常独特。\n什么是尔格数据以及它的实际用例是什么？ 主网将在多久之后执行？ 尔格数据计划成为一个具有相同技术的区块链，但不同的参数可满足面向数据的应用需求。现在我们完全专注于在其上推出单链和应用。我认为尔格数据可能会在2到3年后出现，如果需要这样的应用，并且还可能又基于尔格之上的应用限制（特别是数据密集型）。按说，将会有一个侧链。现在这个领域已经有很好的进展，所以到那时我们可能会有无条件好的侧链。\n什么时候开始挖矿？我们可以用cpu挖矿吗？ 当然，您现在可以开始使用CPU进行挖掘。只需使用mining = true config settings设置一个完整节点（查看本指南），您的节点将在初始同步后开始挖矿。可以在此处找到示例配置\n但是我们还没有上主网呢？所以我们只能挖掘测试网硬币？ 是的，你现在只能挖掘测试网硬币。 GPU 矿工绝对可以在主网之前使用（可能是本周或下周）。\n是否有关于如何设置钱包的手册？ 钱包是在主网发布之前应该更新的另一件事，我们会就它的安全设置等提出建议。现在，您只能在设置帖子的配置文件部分2中将助记词设置为纯文本\n运行节点的最低要求是什么？ 这一切都取决于你的节点制度。我们没有精确测量它，我们用4 Gb内存，2个CPU，80 Gb SSD驱动上打开我们的全部节点，但它就像推荐的配置，而不是最小的配置。\n您是否计划与其他平台合作（例如Waves）？哪一种？ 我们计划在Waves DEX上市（这将大大简化EFYT / 尔格币互换），没有计划与平台的其他合作。\n您有计划增加一个选择来生成类似ERC721的代币吗？无法拆分的令牌。 您可以免费为每个交易发行一个代币，因此发行大量代币（最大供应量为1）不是问题。没有标准可以将它们组合成一类相似的代币（没有标准的方法来检查，标记aa \u0026hellip; aa与标记aa...bb具有相同类别的代币），但可能在将来会出现这样的标准。\n是否可以同时播报一批交易？理想情况下，它们包含在同一区块中。 没有API方法可以同时播报批量交易，但没有什么可以阻止您逐个广播它们而没有延迟。因此，同时播报尽可能多的交易不应该是一个问题。理想情况下，它们应包含在同一个区块中 - 可以编写某种合约，确保一些交易包含在一个单一的交易中阻止（或者没有包括它们）但是，我们还没有尝试过。此外，这可能需要矿工具有从内存池收集交易的修改规则。\n是否可以选择使用0值资产发送交易？ 所以代币在交易中，它的数量是0？不，那是不可能的\n是否有选择发送“广告”交易？ 交易的该费用由自定义代币支付。 它可能是使用交换示例完成的，因此您可以创建一个为尔格购买代币的合约，当发件人要发送代币时—他会卖出所需数量的代币并将剩余的代币数量转移到里面一笔交易。\n所以没有办法转移0.0000001的代币？ 尔格中的每个输出都应该包含一定量的尔格币。 交易费用可能为0，但您应该为每个创建的输出放一定数量的尔格币。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_03_19-qa/","subtitle":null,"title":"Alex Chepurnoy 和Dmitry Meshkov的问答"},{"contents":"","link":"/cn/blog/2019_03_19-qa/","permalink":"https://ergoplatform.org/cn/news/2019-03-19/","subtitle":"与开发团队Alex Chepurnoy和Dmitry Meshkov的问答环节笔录","title":"问答环节记录。主链计划于5月26日发布"},{"contents":"节点安全性 为保证您的钱包和资产的安全，请格外注意以下几个节点使用中的注意事项：\n Ergo节点要求在设置文件中存储一定的关键安全参数，因此，切勿泄露您的设置文件。 Ergo节点已为内置钱包的交互提供了REST API（变现层状态转移编程接口）。灵敏API手段需要安全的通证，切勿采取非信任的渠道发送通证。  节点环境设置 您需要安装至少JRE 8.0 版本来运行Ergo节点。安装方法之一是通过Oracle执行的Java。\n设置Ergo节点 当运行环境设置完备，您就可以下载最新版的Ergo客户端（Ergo client release）创建一个设置文件了。至于jar包，不需要单独下载，您只需要用SBT通过sbt assembly指令来克隆一份资源库，就可创建您自己的jar包\n所有的设置参数都可以在默认设置文件（(default configuration file](https://github.com/ergoplatform/ergo/blob/master/src/main/resources/reference.conf)）中找到。在您的设置文件基础上，您只需重写您在默认值基础上想要进行改动的参数即可。比如，在该设置文件样本（sampleconfiguration file）中您可以查看最新的测试网，里面只包含了一些重要的参数。请注意，在这个样本文件中，您必须去除以下几行指令：\ntestMnemonic = ... testKeysQty = ... 现在，我们来运行下面几个重要步骤： 、设置一个API密钥： 设置API端口密钥。要想设置钱包，您需要先通过节点设置文件来设置apiKeyHash参数，参见此处。文件中要编辑替换：\njavascript scorex.restApi.apiKeyHash = \u0026quot;replace_this_with_your_unique_api_key_hash\u0026quot; \n替换值是在运行您的API请求时生成的密码字符，是一串hex加密Blake2b256哈希数值。您可以使用这个脚本或任意其他脚本来计算blake2b哈希值。密码字符应该是一串随机字符，请务必保管妥善，切勿发给任何非信任方。 这个REST API终端也提供了一个（不受保护的）哈希计算办法：\n/utils/hashBlake2b\n初始化钱包： 这里就用到了前一个步骤提及的API端口密钥。第一次运行节点时，需要先通过REST API对钱包进行初始化，有两个办法可以做到：\n  从头初始化（节点会生成一个种子文件）：向/wallet/init发送一个包含数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: \u0026quot;abc\u0026quot;}的POST请求（提示：别忘了保存下来助记词，节点响应要用到。请求中的mnemonicPass参数是可选项，它用来保护助记词）\n  从已有种子文件恢复钱包：该方法需要您提供助记词。向/wallet/restore发送一个包含数据body: {\u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;, \u0026quot;mnemonic\u0026quot;: \u0026quot;abandon abandon ...\u0026quot;, \u0026quot;mnemonicPass\u0026quot;: “abc”}的POST请求（提示：mnemonicPass部分只有在您的助记词有额外密码保护的情况下才用得到）。\n  解锁钱包： 钱包初始化之后，向/wallet/unlock发送一个包含数据body: {\u0026quot;pass\u0026quot;: “123”}的POST请求（提示：使用您在初始阶段用的密码）\n更多关于钱包的细节描述，请查看此处。\n运行Ergo节点 用ergo-assembly-\u0026lt;version\u0026gt;.jar二进制和ergo.conf设置文件运行节点：\n$ java -jar ergo-assembly-\u0026lt;version\u0026gt;.jar ergo.conf 为确保节点在运行，在浏览器里打开127.0.0.1:9052/info这里会显示关于节点的相关信息。\n使用REST API 节点会提供REST API（相关描述） 您可以用Swagger来完成API请求，访问127.0.0.1:9052/swagger。API完整说明可以在这里找到。要接入受保护的API端口路径，需把您在前面步骤创建的密码字符，输入到[api_key, Content-Type]部分，或者点Swagger里的Authorize按键然后键入您的密码字符。\n关闭控制端打印Console Printing 默认情况下，Ergo节点会打印大量排错信息，这个功能可以关闭，在src/main/resources里编辑logback.xml，然后重新编译（或直接在jar包里编辑XML文件）。编辑以下指令：\n\u0026lt;root level=\u0026#34;WARN\u0026#34;\u0026gt; \u0026lt;!-- other options are TRACE, ERROR --\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34;/\u0026gt; \u0026lt;!-- remove this line to disable all printing --\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; 或者也可以在运行节点时设置想要的参数，如：\njava -jar ergo-assembly-\u0026lt;version\u0026gt;.jar ergo.conf -Dlogback.stdout.level = ERROR ","link":null,"permalink":"https://ergoplatform.org/cn/blog/2019_03_17_how_to_set/","subtitle":null,"title":"如何创建跟设置Ergo全节点"},{"contents":"","link":"https://ergoplatform.org/cn/blog/2019_03_17_how_to_set/","permalink":"https://ergoplatform.org/cn/news/2019-03-17-how-to-set-up-full-node/","subtitle":"教学：如何安装及配置Ergo节点","title":"如何设置和配置尔格全节点"},{"contents":"","link":"https://github.com/ergoplatform/ergo/releases/tag/v2.0.0","permalink":"https://ergoplatform.org/cn/news/2019-03-14/","subtitle":"Ergo上线前的里程碑！主要性能已全部实现，现进入调试阶段，只剩进行性能优化及安全审计等最后调试。至此，平台与主网二进制兼容，快来Ergo上开发你的Dapp吧！","title":"侧链2.0已发布！智能合约语言已更新"},{"contents":"如今，很多与区块链相关的新闻都在告诉我们，银行X或Y公司将使用“区块链”来“降低成本”。基本上，这意味着大银行家认为另一个流行术语只是另一种以更有效的方式从某处提取价值的工具，也可以通过裁员来节省成本。\n虽然我不想对“Satoshi的愿景”说什么（他离开后只能去猜测），但我在网络论坛用户早期见证下的广泛观点是加密货币应该提供能使普通人变得富裕的工具，他们的小企业背后提供的不是生活收入，而不是非个人化的大金融资本。从最初广泛的社区愿景看来，加密货币的工具应该允许人们进行经济活动，而不依赖于业务规模，地理位置，大公司设定的利率等等。这些工具应该允许人们签订合同（没有纸质合约，而是数字化，自我执行和合理智能的合约），这取决于司法管辖区，传统，遵循商业惯例等方面的差异。\n我希望尔格在这方面发挥作用。成千上万的小型合作社和个体企业家对全球健康和可持续的财富增长更为重要，而不是几家公司在离岸天堂中牟利。\n例如，让我们考虑一个合作联盟（如Radical Routes激进路线），愿意为数千公里以外的企业家提供经济援助（例如，在Rojava）。\n我们现在需要假设一些细节。首先，假设网络中有四个合作社。他们在合约中共同锁定10,000 个尔格币（均分四等份，即每份2,500个尔格币），其中说明如下：\n 合作社与公钥pubkeyA，pubkeyB，pubkeyC，pubkeyD相关联。企业家与公钥businessKey关联。 合作社将资金锁定在受融资合约保护的硬币中，然后进行尽职调查，并就是否为企业家提供资金进行投票。所有合约基金（10,000个尔格币）都是给企业家的，如果4个中有3个投了票的话。从技术上讲，投票是通过3/4阈值签名完成的。如果在区块编号1,000之前投票不成功（没有达到3/4的签名），任何合作社（实际上，任何人）都可以提交撤销交易，这将向每个合作社返回2,500个尔格币（至少）。此外，融资合同也将被称为投票合同。 投资可以花在三个目标上，并且有一些严格的限制。也就是说，企业家必须在设备上花费至少5,000个尔格币，在建造所需建筑时至少需要2,000个尔格币，企业家可能会随意花费其他资金。 为了确保设备资金将用于设备，合作社联合会使用企业家领域中已知设备销售商的公钥。例如，考虑设备销售商在该区域中使用公钥pubkeyTool1，pubkeyTool2，pubkeyTool3，pubkeyTool4。从技术上讲，转移是作为一个设备销售商的集体签名组织的（因此来自设备销售商的环签名和企业家的签名） 类似地，假设合作联盟中有3个创建者正在识别，与公钥pubkeyConstr1，pubkeyConstr2和pubkeyConstr3相关联。 与投票合约类似，如果设备和建设合约在5000号区块之前没有共同签署，联合合作社可以撤回资金。  在尔格中定义合约的方法有很多种。 低级语言尔格树中的一个脚本描述了一个（单个）逻辑条件，关于是否可以根据它使用硬币，以及支出交易提供的支出证明。 在内部，条件表示为类型化语法树这一名称。 该结构允许我们进行提前成本分析等。名为尔格脚本的高级语言允许具有更传统和可读的描述，使用变量并将逻辑分解为子程序。\n让我们从上面（1-3）中定义的主合约开始：\n{ val spendingSuccess = (pubkeyTool1 || pubkeyTool2 || pubkeyTool3 || pubkeyTool4) \u0026amp;\u0026amp; businessKey val withdrawCondition = HEIGHT \u0026gt; 5000L \u0026amp;\u0026amp; OUTPUTS(0).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(0).propositionBytes == pubkeyA.propBytes \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(1).propositionBytes == pubkeyB.propBytes \u0026amp;\u0026amp; OUTPUTS(2).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(2).propositionBytes == pubkeyC.propBytes \u0026amp;\u0026amp; OUTPUTS(3).value \u0026gt;= 1250L \u0026amp;\u0026amp; OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } 尔格脚本中的这个脚本将通过与变量的具体值（pubkeyA，pubkeyB，pubkeyC，pubkeyD，spendContract1Hash，spendContract2Hash）绑定，编译成语法树（以序列化形式写入区块链）。 spendContract1Hash是（序列化）设备支出脚本的哈希，将在下面提供具体脚本，spendContract2Hash是一个建造支出脚本的哈希。\n设备支出脚本如下：\n{ val spendingSuccess = (pubkeyConstr1 || pubkeyConstr2 || pubkeyConstr3) \u0026amp;\u0026amp; businessKey val withdrawCondition = HEIGHT \u0026gt; 5000L \u0026amp;\u0026amp; OUTPUTS(0).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(0).propositionBytes == pubkeyA.propBytes \u0026amp;\u0026amp; OUTPUTS(1).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(1).propositionBytes == pubkeyB.propBytes \u0026amp;\u0026amp; OUTPUTS(2).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(2).propositionBytes == pubkeyC.propBytes \u0026amp;\u0026amp; OUTPUTS(3).value \u0026gt;= 500L \u0026amp;\u0026amp; OUTPUTS(3).propositionBytes == pubkeyD.propBytes spendingSuccess || withdrawCondition } 现在假设合作联盟创建了一个受投票合约保护的硬币。以下是企业家如何开展业务：\n 创建一个消耗硬币并创建至少三个硬币的交易，一个与设备支出合同，另一个与建筑支出合同，第三个是创建由企业家的公钥保护的硬币。 将交易发送给合作社，等待交易，并在区块链上发布阈值签名输入。 考虑与设备销售商签订合同，共同签署支出交易。 考虑与建筑商签订合同，共同签署支出交易。  企业家可以轻松逃离而不做任何业务，但不超过3,000尔格币。这可以是固定的，例如这笔钱只能在5000数量的区块之后才能消费，之前合作社可以提取这笔钱。对于设备和建筑支出，企业家正在与一些可能已经声誉良好的企业合作。这样投资者就能降低风险。\n您可以在线查找代码和示例交易。请注意，我们有更多复杂签名方案的例子，多步合约（具有在线执行路径显示，比如比特币中的MAST，但允许循环），oracles（数据库），众筹等等。请查看我们的示例库。\n","link":null,"permalink":"https://ergoplatform.org/cn/blog/2018_10_19-smart-contracts/","subtitle":null,"title":"为客户提供智能合约"},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/exchanges/","subtitle":null,"title":""},{"contents":"","link":null,"permalink":"https://ergoplatform.org/cn/search/","subtitle":"Search page","title":"Search"}]